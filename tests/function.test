# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# This file contains tests for cffi::dyncall::Library pertaining to definition and
# invocation of functions.

source [file join [file dirname [info script]] common.tcl]

namespace eval ${NS}::test {
    testDll function getEinvalString void {buf {chars[1000] out}}
    variable einvalMessage
    getEinvalString einvalMessage
}

# Function definition tests

namespace eval ${NS}::test {

    testnumargs function "testDll function" "NAME RETURNTYPE PARAMDEFS" ""

    test function-noargs-0 {Basic function definition} -cleanup {
        rename noargs {}
    } -body {
        testDll function noargs int {}
        noargs
    } -result 42

    test function-noargs-error-0 {Basic function definition - wrong number of args} -cleanup {
        rename noargs {}
    } -body {
        testDll function noargs int {}
        list [catch {noargs 0} result] $result $::errorCode
    } -result [list  1 {Syntax: noargs} {cffi ERROR {Syntax: noargs}}]

    test function-alias-0 {Function alias} -cleanup {
        rename noargs-alias {}
    } -body {
        testDll function {noargs noargs-alias} int {}
        list [noargs-alias] [catch {noargs} result] $result
    } -result [list 42 1 {invalid command name "noargs"}]

    test function-alias-error-0 {Function alias - wrong args} -cleanup {
        rename noargs-alias {}
    } -body {
        testDll function {noargs noargs-alias} int {}
        list [catch {noargs-alias 0} result] $result $::errorCode
    } -result [list  1 {Syntax: noargs-alias} {cffi ERROR {Syntax: noargs-alias}}]

    test function-alias-error-1 {Function alias - invalid alias} -body {
        list [catch {testDll function {noargs noargs-alias extra} int {}} result] $result $errorCode
    } -result [list 1 {Invalid value "noargs noargs-alias extra". Empty or invalid function name specification.} {cffi INVALID_VALUE {Invalid value "noargs noargs-alias extra". Empty or invalid function name specification.}}]

    test function-multiargs-0 {Multiple parameter function} -cleanup {
        rename twoargs {}
    } -body {
        testDll function twoargs int {a int b int}
        twoargs 1 2
    } -result 3

    test function-multiargs-error-0 {Multiple parameter function - no args} -cleanup {
        rename twoargs {}
    } -body {
        testDll function twoargs int {a int b int}
        list [catch twoargs result] $result $::errorCode
    } -result [list  1 {Syntax: twoargs a b} {cffi ERROR {Syntax: twoargs a b}}]

    test function-multiargs-error-1 {Multiple parameter function - one args} -cleanup {
        rename twoargs {}
    } -body {
        testDll function twoargs int {a int b int}
        list [catch {twoargs 0} result] $result $::errorCode
    } -result [list  1 {Syntax: twoargs a b} {cffi ERROR {Syntax: twoargs a b}}]

    test function-multiargs-error-2 {Multiple parameter function - extra args} -cleanup {
        rename twoargs {}
    } -body {
        testDll function twoargs int {a int b int}
        list [catch {twoargs 0 0 0} result] $result $::errorCode
    } -result [list  1 {Syntax: twoargs a b} {cffi ERROR {Syntax: twoargs a b}}]

    test function-namespace-0 {Function in global namespace} -cleanup {
        rename ::noargs {}
    } -body {
        uplevel #0 [list ${NS}::test::testDll function noargs int {}]
        list [info commands ::noargs] [::noargs]
    } -result [list ::noargs 42]

    test function-namespace-1 {Function in explicit namespace} -cleanup {
        namespace delete ${NS}::test::temp
    } -body {
        namespace eval ${NS}::test::temp [list ${NS}::test::testDll function noargs int {}]
        ${NS}::test::temp::noargs
    } -result 42

    test function-namespace-2 {Function alias in explicit namespace} -cleanup {
        namespace delete ${NS}::test::temp
    } -body {
        namespace eval ${NS}::test::temp [list ${NS}::test::testDll function {noargs noargs-alias} int {}]
        ${NS}::test::temp::noargs-alias
    } -result 42

    test function-error-0 {Missing function} -body {
        list [catch {testDll function nosuchfunction int {}} result] $result $::errorCode
    } -result {1 {Symbol "nosuchfunction" not found or inaccessible. } {cffi NOT_FOUND {Symbol "nosuchfunction" not found or inaccessible. }}}

    test stdcall-0 {stdcall} -body {

        if {$::tcl_platform(platform) eq "windows" && $::tcl_platform(pointerSize) == 4} {
            # VC++ has _, mingw does not
            set fn _stdcalltest@16
            if {[catch {testDll stdcall $fn double {a double b double}}]} {
                set fn stdcalltest@16
                testDll stdcall $fn double {a double b double}
            }
        } else {
            set fn stdcalltest
            testDll stdcall stdcalltest double {a double b double}
        }
        $fn 1 2
    } -result 0.5

    test functions-0 {Multiple functions} -cleanup {
        rename onearg {}
        rename twoargs-alias {}
    } -body {
        testDll functions {
            onearg int {a int}
            {twoargs twoargs-alias} int {a int b int}
        }
        list [onearg 2] [twoargs-alias 1 2] [catch {twoargs 1 2}] [catch {uplevel #0 onearg 0}]
    } -result {-2 3 1 1}

    test functions-1 {Multiple functions in namespace} -setup {
    } -cleanup {
        namespace delete ${NS}::test::temp
    } -body {
        namespace eval ${NS}::test::temp {
            ${NS}::test::testDll functions {
                onearg int {a int}
                {twoargs twoargs-alias} int {a int b int}
            }
        }
        list [${NS}::test::temp::onearg 2] [${NS}::test::temp::twoargs-alias 1 2]
    } -result {-2 3}

    test functions-2 {Multiple functions - empty} -body {
        testDll functions {}
    } -result {}

    test functions-error-0 {Multiple functions - invalid count} -body {
        testDll functions {onearg}
    } -result {Invalid value "onearg". Incomplete function definition list.} -returnCodes error

    test stdcalls-0 {Multiple stdcalls} -cleanup {
        rename $fn {}
        rename stdcall-alias {}
    } -body {
        if {$::tcl_platform(platform) eq "windows" && $::tcl_platform(pointerSize) == 4} {
            set fn _stdcalltest@16
        } else {
            set fn stdcalltest
        }
        set fnlist [list \
                        $fn double {a double b double} \
                        [list $fn stdcall-alias] double {a double b double} \
                       ]
        if {[catch {testDll stdcalls $fnlist}] && $fn eq "_stdcalltest@16"} {
            # Mingw does not prefix _
            set fn stdcalltest@16
            set fnlist [list \
                            $fn double {a double b double} \
                            [list $fn stdcall-alias] double {a double b double} \
                           ]
            testDll stdcalls $fnlist
        }

        list [$fn 1.0 2] [stdcall-alias 1 4.0] [catch [list uplevel #0 $fn 1 2]]
    } -result {0.5 0.25 1}

    # Basic type conversion to test input parameters and return types

    foreach type [linsert $numericTypes end string] {
        # Define functions for number to number
        foreach to_type $numericTypes {
            testDll function ${type}_to_${to_type} $to_type [list param $type]
        }
        testDll function ${type}_to_void void [list param $type]
        test ${type}_to_void "void ($type)" -body {
            ${type}_to_void 0
        } -result ""
        foreach to_type $intTypes {
            test ${type}_to_${to_type}-0 "$to_type ($type = 0)" -body {
                ${type}_to_${to_type} 0
            } -result 0
        }
        foreach to_type $realTypes {
            test ${type}_to_${to_type}-0 "$to_type ($type = 0)" -body {
                ${type}_to_${to_type} 0
            } -result 0.0
        }
    }

    # NOTE: these also test "in" parameter types for pointer, chars, bytes, binary
    foreach to_type $intTypes {
        testDll function pointer_to_$to_type $to_type [list param {pointer unsafe}]
        testDll function [list string_to_$to_type chars_to_$to_type] $to_type [list param {chars[20]}]
        testDll function [list string_to_$to_type bytes_to_$to_type] $to_type [list param {bytes[20]}]
        testDll function [list string_to_$to_type binary_to_$to_type] $to_type [list param binary]

        test pointer_to_${to_type}-0 "$to_type (pointer = 0)" -body {
            pointer_to_${to_type} 0^
        } -result 0

        test chars_to_${to_type}-0 "$to_type (chars = 123)" -body {
            chars_to_${to_type} 123
        } -result 123

        test bytes_to_${to_type}-0 "$to_type (bytes = 123)" -body {
            bytes_to_${to_type} 123\0
        } -result 123

        test binary_to_${to_type}-0 "$to_type (bytes = 123)" -body {
            binary_to_${to_type} 123\0
        } -result 123
    }


    ###
    # Parameter tests

    ## Parameter tests - Numeric types
    foreach type $numericTypes {
        set val [expr {$type in {float double} ? "1.0" : "1"}]

        test function-paramin-$type-0 "$type in params" -setup {
            set fn ${type}_to_${type}
            testDll function $fn $type [list param [list $type in]]
        } -body {
            $fn $val
        } -result $val

        set fn ${type}_byref
        testDll function $fn $type [list inparam [list $type byref]]
        test function-parambyref-$type-0 "$type byref params" -body {
            $fn $val
        } -result [expr {2+$val}]
        testDll function $fn $type [list inparam [list $type in byref]]
        test function-parambyref-$type-1 "$type in byref params" -body {
            $fn $val
        } -result [expr {2+$val}]

        set fn ${type}_out
        testDll function $fn $type [list inparam [list $type in] outparam [list $type out]]
        test function-paramout-$type-0 "$type out params" -body {
            unset -nocomplain out
            list [$fn $val out] $out
        } -result [list [expr {2+$val}] [expr {1+$val}]]
        test function-paramout-$type-1 "$type out params - existing var" -body {
            set out 99
            list [$fn $val out] $out
        } -result [list [expr {2+$val}] [expr {1+$val}]]
        test function-paramout-$type-2 "$type out params - existing array var" -cleanup {
            unset arr
        } -body {
            set arr(x) x
            list [$fn $val arr] $arr
        } -result [list [expr {2+$val}] [expr {1+$val}]]

        test function-paraminout-$type-0 "$type inout params" -setup {
            set fn ${type}_inout
            testDll function $fn $type [list inoutparam [list $type inout]]
        } -body {
            set param $val
            list [$fn param] $param
        } -result [list [expr {2+$val}] [expr {1+$val}]]

        foreach attr [linsert $pointerAttrs end nullifempty] {
            test function-param-$type-$attr-error-0 "$type invalid attribute" -body {
                testDll function ${type}_to_void void [list param [list $type $attr]]
            } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error
        }

        foreach attr $errorAttrs {
            if {$type in $intTypes} {
                set msg $errorMessages(attrparsemode)
            } else {
                set msg $errorMessages(attrtype)
            }
            test function-param-$type-$attr "$type invalid attribute" -body {
                testDll function ${type}_to_void void [list param [list $type $attr]]
            } -result "Invalid value \"$type $attr\". $msg" -returnCodes error
        }
    }

    ## Parameter tests - string, unistring
    # String is tested earlier for input parameters.
    foreach {type val} [list string abc unistring "\xe0\xe1\xe2"] {
        set len [string length $val]
        set repeat 100000
        set largelen [expr {[string length $val] * $repeat}]
        set largeval [string repeat $val $repeat]

        set fn ${type}_len
        testDll function $fn int [list input $type]
        test function-$type-in-0 "$type in" -body {
            $fn $val
        } -result $len
        test function-$type-in-1 "$type in large" -body {
            $fn $largeval
        } -result $largelen

        set fn ${type}_out
        test function-$type-out-error-0 "$type out" -body {
            testDll function $fn int [list inparam $type outparam [list $type out]]
        } -result "Invalid value \"$type out\". A type annotation is not valid for the data type." -returnCodes error

        set fn ${type}_reverse_inout
        test function-$type-inout-error-0 "$type inout" -body {
            testDll function $fn int [list param [list $type inout]]
        } -result "Invalid value \"$type inout\". A type annotation is not valid for the data type." -returnCodes error

        foreach attr $pointerAttrs {
            test function-param-$type-$attr-error-0 "$type invalid attribute" -body {
                testDll function ${type}_to_void void [list param [list $type $attr]]
            } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error
        }

        foreach attr $errorAttrs {
            if {$type in $intTypes} {
                set msg $errorMessages(attrparsemode)
            } else {
                set msg $errorMessages(attrtype)
            }
            test function-param-$type-$attr "$type invalid attribute" -body {
                testDll function ${type}_to_void void [list param [list $type $attr]]
            } -result "Invalid value \"$type $attr\". $msg" -returnCodes error
        }

        test function-$type-nullifempty-0 "$type in nullifempty" -setup {
            testDll function pointer_to_pointer {pointer unsafe} {s {string nullifempty}}
        } -body {
            pointer_to_pointer ""
        } -result [makeptr 0]
        test function-$type-nullifempty-1 "$type in nullifempty non-empty" -setup {
            testDll function ${type}_len int [list param [list $type nullifempty]]
        } -body {
            ${type}_len abc
        } -result 3
    }


    # string.encoding
    # Note: do not include ascii for jis0208 encoding tests.
    # See https://core.tcl-lang.org/tcl/tktview/9bad909c6ed4691bcad1886d710a923791a524a2
    set val \u543e
    set encoded 8c
    set bufsize 100000
    testDll function jis0208_in int [list x string.jis0208]
    test function-string-encoding-in-0 "string encoding in" -body {
        jis0208_in \u543e
    } -result 1
    test function-string-encoding-in-1 "string encoding in large" -body {
        jis0208_in [string repeat \u543e [expr {$bufsize/2 - 1}]]
    } -result [expr {$bufsize/2 - 1}]
    test function-string-encoding-in-error-1 "string bad encoding" -body {
        testDll function jis0208_in int [list x string.nosuchencoding]
    } -result {unknown encoding "nosuchencoding"} -returnCodes error


    ## Parameter tests - chars, unichars
    foreach {type val} [list chars abc chars.utf-8 abc unichars "\xe0\xe1\xe2"] {
        set len [string length $val]
        set buflen [expr {$len+1}]
        set repeat 100000
        set largelen [expr {[string length $val] * $repeat}]
        set largebuflen [expr {$largelen+1}]
        set largeval [string repeat $val $repeat]
        if {$type in {chars chars.utf-8}} {
            set fn string_out
        } else {
            set fn unistring_out
        }
        testDll function $fn int [list input "$type\[$buflen\]" output [list $type\[$buflen\] out]]
        test function-$type-out-0 "$type out" -body {
            list [$fn $val result] $result
        } -result [list $len $val]
        test function-$type-out-1 "$type out empty string" -body {
            list [$fn "" result] $result
        } -result {0 {}}
        testDll function $fn int [list input "$type\[$largebuflen\]" output [list $type\[$largebuflen\] out]]
        test function-$type-out-2 "$type out" -body {
            list [$fn $largeval result] $result
        } -result [list $largelen $largeval]
        test function-$type-out-3 "$type out - uninitialized output" -setup {
            testDll function pointer_noop void [list s [list $type\[4\] out]]
        } -body {
            # This test attempts to check that the library guards against the called
            # function not initializing the output buffer, for example in case of
            # errors. This is not fool proof as there is no way to control existing
            # output buffer contents before calling function (inout is not the same case)
            # We expect the output buffer to be init'ed to leading \0
            pointer_noop output
            set output
        } -result ""

        if {$type in {chars chars.utf-8}} {
            set fn string_reverse_inout
        } else {
            set fn unistring_reverse_inout
        }
        testDll function $fn int [list param [list $type\[$buflen\] inout]]
        test function-$type-inout-0 "$type inout" -body {
            set result $val
            list [$fn result] $result
        } -result [list $len [string reverse $val]]
        test function-$type-inout-1 "$type inout empty string" -body {
            set result ""
            list [$fn result] $result
        } -result {0 {}}
        test function-$type-inout-error-0 "$type inout" -body {
            set result "abcd"
            $fn result
        } -result "Invalid value*length is greater than specified maximum buffer size." -returnCodes error -match glob
        testDll function $fn int [list param [list $type\[$largebuflen\] inout]]
        test function-$type-inout-2 "$type inout" -body {
            set result $largeval
            list [$fn result] $result
        } -result [list $largelen [string reverse $largeval]]

        if {$type in {chars chars.utf-8}} {
            set fn chars_to_void
        } else {
            set fn ${type}_to_void
        }
        foreach attr [linsert $pointerAttrs end nullifempty] {
            test function-param-$type-$attr-error-0 "$type invalid attribute" -body {
                testDll function $fn void [list param [list $type\[2\] $attr]]
            } -result "Invalid value \"{$type\[2\]} $attr\". $errorMessages(attrtype)" -returnCodes error
        }

        foreach attr $errorAttrs {
            if {$type in $intTypes} {
                set msg $errorMessages(attrparsemode)
            } else {
                set msg $errorMessages(attrtype)
            }
            test function-param-$type-$attr "$type invalid attribute" -body {
                testDll function $fn void [list param [list $type\[2\] $attr]]
            } -result "Invalid value \"{$type\[2\]} $attr\". $msg" -returnCodes error
        }
    }

    # chars.encoding
    set val \u543e
    set encoded 8c
    set bufsize 100000
    testDll function jis0208_in int [list x chars.jis0208\[$bufsize\]]
    test function-chars-encoding-in-0 "chars encoding in" -body {
        jis0208_in \u543e
    } -result 1
    test function-chars-encoding-in-1 "chars encoding in large" -body {
        jis0208_in [string repeat \u543e [expr {$bufsize/2 - 1}]]
    } -result [expr {$bufsize/2 - 1}]
    test function-chars-encoding-in-error-0 "chars encoding in large overflow" -body {
        jis0208_in [string repeat \u543e [expr {$bufsize/2}]]
    } -result "Invalid value*String length is greater than specified maximum buffer size." -returnCodes error -match glob
    test function-chars-encoding-in-error-1 "chars bad encoding" -body {
        testDll function jis0208_in int [list x chars.nosuchencoding\[10\]]
    } -result {unknown encoding "nosuchencoding"} -returnCodes error

    testDll function jis0208_out void [list bufsize int buf [list chars.jis0208\[$bufsize\] out]]
    test function-chars-encoded-out-0 "encoded out" -body {
        jis0208_out 4 out
        set out
    } -result $val
    test function-chars-encoded-out-1 "encoded out large" -body {
        jis0208_out $bufsize out
        set out
    } -result [string repeat $val [expr {$bufsize/2 - 1}]]

    testDll function jis0208_inout void [list param [list chars.jis0208\[20\] inout]]
    test function-chars-encoded-inout-0 "encoded inout" -body {
        set param [string repeat $val 2]
        jis0208_inout param
        set param
    } -result [string repeat $val 4]

    ## Parameter tests - bytes

    set val \x01\x02\x03
    set len [string length $val]
    set largeval [string repeat $val $repeat]
    set largelen [string length $largeval]
    test function-bytes-in-0 "bytes in dynamic count (count, array)" -setup {
        testDll function uchar_array_in uchar {n int buf bytes[n]}
    } -body {
        uchar_array_in $len $val
    } -result 6
    test function-bytes-in-1 "bytes in dynamic count (array, count)" -setup {
        testDll function uchar_array_count_in uchar {buf bytes[n] n int}
    } -body {
        uchar_array_count_in $val $len
    } -result 6
    test function-bytes-out-0 "bytes out" -setup {
        testDll function bytes_out void [list n int input bytes\[$len\] output [list bytes\[$len\] out]]
    } -body {
        bytes_out $len $val out
        set out
    } -result $val
    test function-bytes-out-1 "bytes out large" -setup {
        testDll function bytes_out void [list n int input bytes\[$largelen\] output [list bytes\[$largelen\] out]]
    } -body {
        bytes_out $largelen $largeval out
        set out
    } -result $largeval

    test function-bytes-inout-0 "bytes inout" -setup {
        testDll function bytes_inout void [list n int output [list bytes\[$len\] inout]]
    } -body {
        set out $val
        bytes_inout $len out
        set out
    } -result [string reverse $val]
    test function-bytes-inout-1 "bytes inout large" -setup {
        testDll function bytes_inout void [list n int output [list bytes\[$largelen\] inout]]
    } -body {
        set out $largeval
        bytes_inout $largelen out
        set out
    } -result [string reverse $largeval]
    test function-bytes-inout-error-0 "bytes inout buffer size error" -setup {
        testDll function bytes_inout void [list n int output [list bytes\[1\] inout]]
    } -body {
        set out $val
        bytes_inout 1 out
    } -result "Invalid value. Byte array length is greater than specified maximum buffer size." -returnCodes error

    ## Parameter tests - binary
    test function-binary-out-error-0 "binary out" -body {
        testDll function bytes_out void [list n int input binary output [list binary out]]
    } -result {Invalid value "binary out". A type annotation is not valid for the data type.} -returnCodes error
    test function-binary-inout-error-0 "binary inout" -body {
        testDll function bytes_inout void [list n int output [list binary inout]]
    } -result {Invalid value "binary inout". A type annotation is not valid for the data type.} -returnCodes error

    ## Parameter tests - pointers
    test function-pointer-in-0 "pointer in" -setup {
        testDll function pointer_in int {p pointer}
        cffi::Struct create TempStruct {i int}
        set p [TempStruct allocate]
        TempStruct tonative $p [list i 42]
    } -cleanup {
        TempStruct free $p
        TempStruct destroy
    } -body {
        pointer_in $p
    } -result 42

    test function-pointer-out-0 "pointer out" -setup {
        testDll function pointer_out void {p {pointer out}}
    } -cleanup {
        cffi::memory free $p
    } -body {
        pointer_out p
        list [cffi::pointer isvalid $p] [binary scan [cffi::memory tobinary $p 4] n val] $val
    } -result [list 1 1 99]

    test function-pointer-inout-0 "pointer inout" -setup {
        testDll function pointer_incr void {p {pointer inout}}
    } -cleanup {
        cffi::memory free $p
    } -body {
        set p [cffi::memory allocate 4]
        set p2 $p
        pointer_incr p2
        set addr [cffi::pointer address $p]
        set addr2 [cffi::pointer address $p2]
        list [cffi::pointer dispose $p2] [expr {$addr+1 == $addr2}]
    } -result [list {} 1]

    test function-pointer-byref-0 "pointer byref" -setup {
        testDll function pointer_byref {pointer unsafe} {p {pointer byref}}
        set p [memory allocate 1]
    } -cleanup {
        cffi::memory free $p
    } -body {
        set p2 [pointer_byref $p]
        expr {$p == $p2}
    } -result 1

    # pointer param safety attributes
    test function-pointer-param-safety-0 "pointer safe to unsafe" -setup {
        cffi::pointer safe 1^
    } -cleanup {
        cffi::pointer dispose 1^
    } -body {
        testDll function pointer_noop void {p {pointer unsafe}}
        pointer_noop 1^
    } -result ""

    test function-pointer-param-safety-1 "pointer unsafe to safe" -body {
        testDll function pointer_noop void {p pointer}
        pointer_noop 1^
    } -result "Pointer [makeptr 1] is not registered." -returnCodes error

    test function-pointer-param-safety-2 "pointer unsafe to unsafe" -body {
        testDll function pointer_noop void {p {pointer unsafe}}
        pointer_noop 1^
    } -result ""

    test function-pointer-param-safety-3 "pointer unsafe to counted" -body {
        testDll function pointer_noop void {p {pointer counted}}
        pointer_noop 1^
    } -result "Pointer [makeptr 1] is not registered." -returnCodes error

    test function-pointer-param-safety-4 "pointer unsafe dispose" -body {
        testDll function pointer_noop void {p {pointer dispose}}
        pointer_noop 1^
    } -result "Pointer [makeptr 1] is not registered." -returnCodes error -match glob

    test function-pointer-param-safety-5 "pointer unsafe dispose conflict" -body {
        testDll function pointer_noop void {p {pointer dispose unsafe}}
    } -result "Invalid value \"pointer dispose unsafe\". $errorMessages(attrconflict)" -returnCodes error

    test function-pointer-param-safety-6 "pointer unsafe counted conflict" -body {
        testDll function pointer_noop void {p {pointer counted unsafe}}
    } -result "Invalid value \"pointer counted unsafe\". $errorMessages(attrconflict)" -returnCodes error

    test function-pointer-param-safety-7 "pointer counted" -setup {
        cffi::pointer counted 1^
    } -body {
        testDll function pointer_noop void {p {pointer counted}}
        pointer_noop 1^
        pointer_noop 1^; # Should not increase reference count when passed as parameter
        list [cffi::pointer isvalid 1^] [cffi::pointer dispose 1^] [cffi::pointer isvalid 1^]
    } -result {1 {} 0}

    test function-pointer-param-safety-8 "pointer safe dispose" -setup {
        cffi::pointer safe 1^
    } -body {
        testDll function pointer_noop void {p {pointer dispose}}
        list [pointer_noop 1^] [cffi::pointer isvalid 1^]
    } -result {{} 0}

    test function-pointer-param-safety-9 "pointer counted dispose" -setup {
        cffi::pointer counted 1^
        cffi::pointer counted 1^
    } -body {
        testDll function pointer_noop void {p {pointer dispose counted}}
        list [pointer_noop 1^] [cffi::pointer isvalid 1^] [pointer_noop 1^] [cffi::pointer isvalid 1^]
    } -result {{} 1 {} 0}

    test function-pointer-param-safety-10 "pointer safe dispose - after param checks" -setup {
        set p [makeptr 1]
        cffi::pointer safe $p
        testDll function pointer_add {pointer unsafe} {p {pointer dispose} n int}
    } -body {
        # Verifies that pointer is not disposed if parameter has an error
        list \
            [cffi::pointer isvalid $p] \
            [catch {pointer_add $p notanint}] \
            [cffi::pointer isvalid $p] \
            [catch {pointer_add $p 0}] \
            [cffi::pointer isvalid $p] 
    } -result {1 1 1 0 0}

    test function-pointer-param-safety-11 "pointer counted dispose - after param checks" -setup {
        set p [makeptr 1]
        cffi::pointer counted $p
        cffi::pointer counted $p
        testDll function pointer_add {pointer unsafe} {p {pointer dispose} n int}
    } -body {
        # Verifies that pointer is not disposed if parameter has an error
        list \
            [cffi::pointer isvalid $p] \
            [catch {pointer_add $p notanint}] \
            [cffi::pointer isvalid $p] \
            [catch {pointer_add $p 0}] \
            [cffi::pointer isvalid $p] \
            [catch {pointer_add $p 0}] \
            [cffi::pointer isvalid $p]
    } -result {1 1 1 0 1 0 0}

    # pointer tags
    test function-pointer-param-tag-0 "pointer tag safe" -setup {
        testDll function pointer_noop void {p pointer.TAG}
        cffi::pointer safe 1^TAG
    } -cleanup {
        cffi::pointer dispose 1^TAG
    } -body {
        pointer_noop 1^TAG
    } -result ""

    test function-pointer-param-tag-1 "pointer tag unsafe" -body {
        testDll function pointer_noop void {p {pointer.TAG unsafe}}
        pointer_noop 1^TAG
    } -result ""

    test function-pointer-param-tag-2 "pointer tag safe - wrong type" -body {
        testDll function pointer_noop void {p pointer.TAG}
        pointer_noop 1^TAG2
    } -result {Value "1^TAG2" has the wrong type. Pointer type mismatch.} -returnCodes error

    test function-pointer-param-tag-3 "pointer tag unsafe - wrong type" -body {
        testDll function pointer_noop void {p {pointer.TAG unsafe}}
        pointer_noop 1^TAG2
    } -result {Value "1^TAG2" has the wrong type. Pointer type mismatch.} -returnCodes error

    test function-pointer-param-tag-4 "pointer tag counted" -setup {
        testDll function pointer_noop void {p {pointer.TAG counted}}
        cffi::pointer counted 1^TAG
    } -cleanup {
        cffi::pointer dispose 1^TAG
    } -body {
        pointer_noop 1^TAG
    } -result ""

    test function-pointer-param-tag-5 "pointer tag counted - wrong type" -body {
        testDll function pointer_noop void {p {pointer.TAG counted}}
        pointer_noop 1^TAG2
    } -result {Value "1^TAG2" has the wrong type. Pointer type mismatch.} -returnCodes error

    # tag dispose
    test function-pointer-param-tag-6 "pointer tag dispose" -setup {
        testDll function pointer_noop void {p {pointer.TAG dispose}}
        cffi::pointer safe 1^TAG
    } -body {
        list [pointer_noop 1^TAG] [cffi::pointer isvalid 1^TAG]
    } -result [list {} 0]

    test function-pointer-param-tag-7 "pointer tag dispose - wrong type" -body {
        testDll function pointer_noop void {p {pointer.TAG dispose}}
        pointer_noop 1^TAG2
    } -result {Value "1^TAG2" has the wrong type. Pointer type mismatch.} -returnCodes error

    test function-pointer-param-tag-8 "pointer tag safe passed to untagged" -setup {
        testDll function pointer_noop void {p pointer}
        cffi::pointer safe 1^TAG
    } -cleanup {
        cffi::pointer dispose 1^TAG
    } -body {
        pointer_noop 1^TAG
    } -result ""

    test function-pointer-param-tag-9 "pointer untagged safe passed to tagged" -setup {
        testDll function pointer_noop void {p pointer.TAG}
        cffi::pointer safe 1^
    } -cleanup {
        cffi::pointer dispose 1^
    } -body {
        list [catch {pointer_noop 1^} result] $result
    } -result {1 {Value "1^" has the wrong type. Pointer type mismatch.}}

    test function-pointer-param-tag-10 "pointer tag unsafe passed to untagged" -setup {
        testDll function pointer_noop void {p {pointer unsafe}}
    } -body {
        pointer_noop 1^TAG
    } -result ""

    test function-pointer-param-tag-11 "pointer untagged unsafe passed to tagged" -setup {
        testDll function pointer_noop void {p {pointer.TAG unsafe}}
    } -body {
        list [catch {pointer_noop 1^} result] $result
    } -result {1 {Value "1^" has the wrong type. Pointer type mismatch.}}

    # Pointer param error attributes
    foreach attr [linsert $errorAttrs end nullifempty] {
        if {$attr in {winerror lasterror}} {
            set constraints win
        } else {
            set constraints {}
        }
        if {$attr in {nonzero lasterror errno}} {
            set msg $errorMessages(attrparsemode)
        } else {
            set msg $errorMessages(attrtype)
        }
        test function-pointer-param-$attr-0 "pointer invalid attribute" -constraints $constraints -body {
            testDll function pointer_to_void void [list param [list pointer $attr]]
        } -result "Invalid value \"pointer $attr\". $msg" -returnCodes error
    }

    ## Parameter - struct
    test function-struct-byval-0 "Param struct by value - error" -body {
        testDll function getTestStruct int {s struct.TestStruct}
    } -result "Invalid value \"struct.TestStruct\". $errorMessages(structbyref)" -returnCodes error

    test function-struct-out-0 "Param struct out" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
    } -body {
        getTestStruct s
        checkTestStruct $s
    } -result [list ]

    test function-struct-out-crash-bug#39 "Param struct out" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        proc crash {} {
            getTestStruct s
            checkTestStruct $s
        }
    } -body {
        crash
    } -result [list ]

    test function-struct-in-0 "Param struct in" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
        testDll function structCheck int {s {struct.::S byref} c uchar ll longlong s short}
    } -body {
        set ll 0x7fffffffffff
        structCheck [list c 1 ll $ll s 2] 1 $ll 2
    } -result 1
    test function-struct-in-1 "Param struct in - null if empty" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
        testDll function pointer_to_pointer {pointer unsafe} {s {struct.::S byref in nullifempty}}
    } -body {
        pointer_to_pointer {}
    } -result [makeptr 0]
    test function-struct-in-2 "Param struct in - null if empty, override" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
        testDll function pointer_to_pointer {pointer unsafe} {s {struct.::S byref in nullifempty}}
    } -body {
        cffi::pointer isnull [pointer_to_pointer {c 0 ll 0 s 0}]
    } -result 0
    
    test function-struct-in-error-0 "Param struct in - empty dictionary" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
        testDll function structCheck int {s {struct.::S byref} c uchar ll longlong s short}
    } -body {
        set ll 0x7fffffffffff
        structCheck [list ] 1 $ll 2
    } -result {Struct field "c" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error
    test function-struct-in-error-1 "Param struct in missing field" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
        testDll function structCheck int {s {struct.::S byref} c uchar ll longlong s short}
    } -body {
        set ll 0x7fffffffffff
        structCheck [list c 1 ll $ll] 1 $ll 2
    } -result {Struct field "s" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error
    test function-struct-in-error-2 "Param struct in missing field - with nullempty" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
        testDll function structCheck int {s {struct.::S byref nullifempty} c uchar ll longlong s short}
    } -body {
        set ll 0x7fffffffffff
        structCheck [list c 1 ll $ll] 1 $ll 2
    } -result {Struct field "s" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error

    test function-struct-inout-0 "Pass struct inout" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        testDll function incrTestStruct void {s {struct.TestStruct inout}}
    } -body {
        getTestStruct s
        incrTestStruct s
        # TBD - fix this result check for all platforms, including 32-bits
        set s
    } -result [expr {$::tcl_platform(platform) eq "windows" ? {c 1 i 5 shrt 9 ui 13 ushrt 17 l 21 uc 25 ul 29 c3 33 ll 49 unic 56 ull 89 b abc f 101.0 s {c 105} d 121.0} : {c 1 i 5 shrt 9 ui 13 ushrt 17 l 25 uc 33 ul 41 c3 49 ll 65 unic 72 ull 105 b qrs f 117.0 s {c 121} d 137.0}}] 
    test function-struct-inout-error-0 "Param struct inout - empty dictionary" -setup {
        testDll function incrTestStruct void {s {struct.TestStruct inout}}
    } -body {
        set s {}
        incrTestStruct s
    } -result {Struct field "c" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error

    # Note -  tests for invalid attrs are done in type.test

    ###
    # Return type tests

    #+ Numeric return types
    # Note Numeric returns types without attributes already tested earlier
    # Only test attributes here
    foreach type $intTypes {
        foreach {attr val} {
            zero 0
            nonzero 1
            nonzero -1
            nonnegative 0
            nonnegative 1
            positive 1
        } {
            set testnum -1
            set fn ${type}_to_$type
            testDll function $fn [list $type $attr] [list param $type]
            if {$val < 0 && $type in $unsignedIntTypes} continue
            test function-return-$type-$attr-$val-[incr testnum] "return $type $attr - $val" -setup {
            } -body {
                $fn $val
            } -result $val
        }
    }
    # Error cases
    foreach type $intTypes {
        foreach {attr val message} {
            zero 1 {Function returned non-zero value.}
            zero -1 {Function returned non-zero value.}
            nonzero 0 {Function returned zero.}
            nonnegative -1 {Function returned negative value.}
            positive 0 {Function returned zero.}
            positive -1 {Function returned negative value.}
        } {
            set testnum -1
            set fn ${type}_to_$type
            testDll function $fn [list $type $attr] [list param $type]
            if {$val < 0 && $type in $unsignedIntTypes} continue
            test function-return-$type-$attr-$val-error-[incr testnum] "return $type $attr - $val" -setup {
            } -body {
                $fn $val
            } -result "Invalid value \"$val\". $message" -returnCodes error
        }

        test function-return-$type-array-0 "return type $type\[\]" -body {
            testDll function ${type}_to_${type} $type\[2\] {}
        } -result "Invalid value \"$type\[2\]\". $errorMessages(arrayreturn)" -returnCodes error
        foreach attr $paramAttrs {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function ${type}_to_${type} [list $type $attr] {}
            } -result "Invalid value \"$type $attr\". $errorMessages(attrparsemode)" -returnCodes error
        }
        foreach attr [linsert $pointerAttrs end nullifempty] {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function ${type}_to_${type} [list $type $attr] {}
            } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error
        }
    }

    # errno, lasterror, winerror
    foreach {attr val} {
        zero 1
        zero -1
        nonzero 0
        nonnegative -1
        positive 0
        positive -1
    } {
        test function-return-errno-$attr-$val-0 "return errno" -setup {
            testDll function setErrno [list int $attr errno] {val int}
        } -body {
            list [catch {setErrno $val} result] [string equal $result $einvalMessage]
        } -result {1 1}

        test function-return-lasterror-$attr-$val-0 "return lasterror" -setup {
            testDll function setWinError [list int $attr lasterror] {val int}
        } -constraints win -body {
            list [catch {setWinError $val} result] $result
        } -result [list 1 "The data is invalid. "]

        if {$attr eq "zero"} {
            test function-return-winerror-zero-$val-0 "return zero winerror" -setup {
                testDll function {int_to_int getWinError} [list int zero winerror] {val int}
            } -constraints win -body {
                list [catch {getWinError 0xd} result] $result
            } -result [list 1 "The data is invalid. "]
        } else {
            test function-return-winerror-$attr-$val-0 "return $attr winerror" -constraints win -body {
                testDll function {int_to_int getWinError} [list int $attr winerror] {val int}
            } -result "Invalid value \"int $attr winerror\". $errorMessages(attrconflict)" -returnCodes error
        }
    }

    # Attributes not permitted for real types
    foreach type $realTypes {
        test function-return-$type-array-0 "return type $type\[\]" -body {
            testDll function ${type}_to_${type} $type\[2\] {}
        } -result "Invalid value \"$type\[2\]\". $errorMessages(arrayreturn)" -returnCodes error
        foreach attr [linsert $errorAttrs end nullifempty] {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function ${type}_to_${type} [list $type $attr] {}
            } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error
        }
        foreach attr $paramAttrs {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function ${type}_to_${type} [list $type $attr] {}
            } -result "Invalid value \"$type $attr\". $errorMessages(attrparsemode)" -returnCodes error
        }
        foreach attr $pointerAttrs {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function ${type}_to_${type} [list $type $attr] {}
            } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error
        }
    }

    # Attributes for pointers
    foreach type {pointer pointer.TAG} {
        # safe
        test function-return-$type-safe-0 "return type $type safe" -body {
            testDll function pointer_to_pointer [list $type] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            list [cffi::pointer isvalid $p] [cffi::pointer dispose $p] [cffi::pointer isvalid $p]
        } -result {1 {} 0}

        # counted
        test function-return-$type-counted-0 "return type $type counted" -cleanup {
        } -body {
            testDll function pointer_to_pointer [list $type counted] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            set p2 [pointer_to_pointer 1^]
            list [string equal $p $p2] \
                [cffi::pointer isvalid $p] \
                [cffi::pointer dispose $p] \
                [cffi::pointer dispose $p2] \
                [cffi::pointer isvalid $p]
        } -result {1 1 {} {} 0}

        # unsafe
        test function-return-$type-unsafe-0 "return type $type unsafe" -body {
            testDll function pointer_to_pointer [list $type unsafe] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            list [cffi::pointer isvalid $p]
        } -result 0

        # Pointer error attributes
        # safe
        test function-return-$type-nonzero-0 "return type $type nonzero" -body {
            testDll function pointer_to_pointer [list $type nonzero] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            list [cffi::pointer isvalid $p] [cffi::pointer dispose $p] [cffi::pointer isvalid $p]
        } -result {1 {} 0}
        test function-return-$type-nonzero-null-0 "return type $type nonzero - null" -body {
            testDll function pointer_to_pointer [list $type nonzero] {p {pointer unsafe}}
            pointer_to_pointer 0^
        } -result "Invalid value *. Function returned NULL pointer." -returnCodes error -match glob
        test function-return-$type-nonzero-errno-0 "return type $type nonzero - errno" -body {
            testDll function pointer_errno [list $type nonzero errno] {p {pointer unsafe}}
            list [catch {pointer_errno 0^} result] [string equal $result $einvalMessage]
        } -result {1 1}
        test function-return-$type-nonzero-lasterror-0 "return type $type nonzero - lasterror" -constraints win -body {
            testDll function pointer_lasterror [list $type nonzero lasterror] {p {pointer unsafe}}
            list [catch {pointer_lasterror 0^} result] $result
        } -result {1 {The data is invalid. }}

        # counted
        test function-return-$type-counted-nonzero-0 "return type $type counted nonzero" -body {
            testDll function pointer_to_pointer [list $type counted nonzero] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            list [cffi::pointer isvalid $p] [cffi::pointer dispose $p] [cffi::pointer isvalid $p]
        } -result {1 {} 0}
        test function-return-$type-counted-nonzero-null-0 "return type $type counted nonzero - null" -body {
            testDll function pointer_to_pointer [list $type counted nonzero] {p {pointer unsafe}}
            pointer_to_pointer 0^
        } -result "Invalid value *. Function returned NULL pointer." -returnCodes error -match glob
        test function-return-$type-counted-nonzero-errno-0 "return type $type counted-nonzero - errno" -body {
            testDll function pointer_errno [list $type nonzero counted errno] {p {pointer unsafe}}
            list [catch {pointer_errno 0^} result] [string equal $result $einvalMessage]
        } -result {1 1}
        test function-return-$type-counted-nonzero-lasterror-0 "return type $type counted-nonzero - lasterror" -constraints win -body {
            testDll function pointer_lasterror [list $type counted nonzero lasterror] {p {pointer unsafe}}
            list [catch {pointer_lasterror 0^} result] $result
        } -result {1 {The data is invalid. }}

        # unsafe
        test function-return-$type-unsafe-nonzero-0 "return type $type unsafe nonzero" -body {
            testDll function pointer_to_pointer [list $type unsafe nonzero] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            cffi::pointer isvalid $p
        } -result 0
        test function-return-$type-unsafe-nonzero-null-0 "return type $type unsafe nonzero - null" -body {
            testDll function pointer_to_pointer [list $type unsafe nonzero] {p {pointer unsafe}}
            pointer_to_pointer 0^
        } -result "Invalid value *. Function returned NULL pointer." -returnCodes error -match glob
        test function-return-$type-unsafe-nonzero-errno-0 "return type $type unsafe-nonzero - errno" -body {
            testDll function pointer_errno [list $type nonzero unsafe errno] {p {pointer unsafe}}
            list [catch {pointer_errno 0^} result] [string equal $result $einvalMessage]
        } -result {1 1}
        test function-return-$type-unsafe-nonzero-lasterror-0 "return type $type unsafe-nonzero - lasterror" -constraints win -body {
            testDll function pointer_lasterror [list $type unsafe nonzero lasterror] {p {pointer unsafe}}
            list [catch {pointer_lasterror 0^} result] $result
        } -result {1 {The data is invalid. }}

        # checks that are not valid for pointers
        foreach attr {zero nonnegative positive nullifempty} {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function pointer_to_pointer [list $type $attr] {p {pointer unsafe}}
            } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error
        }
        set attr winerror
        test function-return-$type-${attr}-0 "return type $type $attr" -constraints win -body {
            testDll function pointer_to_pointer [list $type $attr] {p {pointer unsafe}}
        } -result "Invalid value \"$type $attr\". $errorMessages(attrtype)" -returnCodes error

        # Error cases
        test function-return-$type-safe-dup-0 "return type $type safe - dup" -cleanup {
            cffi::pointer dispose $p
        } -body {
            testDll function pointer_to_pointer [list $type] {p {pointer unsafe}}
            set p [pointer_to_pointer 1^]
            list [cffi::pointer isvalid $p] [catch {pointer_to_pointer 1^} result] [cffi::pointer isvalid $p] $result
        } -result [list 1 1 1 "Registered pointer already exists. "]

        test function-return-$type-array-0 "return type $type\[\]" -body {
            testDll function pointer_to_pointer $type\[2\] {}
        } -result "Invalid value \"$type\[2\]\". $errorMessages(unsupportedarraytype)" -returnCodes error
        test function-return-$type-dispose-0 "return type $type dispose" -body {
            testDll function pointer_to_pointer [list $type dispose] {p {pointer unsafe}}
        } -result "Invalid value \"$type dispose\". $errorMessages(attrparsemode)" -returnCodes error
        foreach attr $paramAttrs {
            test function-return-$type-${attr}-0 "return type $type $attr" -body {
                testDll function pointer_to_pointer [list $type unsafe $attr] {p {pointer unsafe}}
            } -result "Invalid value \"$type unsafe $attr\". $errorMessages(attrparsemode)" -returnCodes error
        }
    }

    # string, unistring return types
    foreach type {string string.utf-8 unistring} {
        test function-return-$type-0 "return $type NULL" -setup {
            testDll function pointer_to_pointer $type {p {pointer unsafe}}
        } -body {
            pointer_to_pointer 0^
        } -result ""
    }
    test function-return-string-1 "return string ascii" -setup {
        testDll function ascii_return string {}
    } -body {
        ascii_return
    } -result "abc"
    test function-return-string-2 "return string utf-8" -setup {
        testDll function utf8_return string.utf-8 {}
    } -body {
        utf8_return
    } -result "\xe0\xe1\xe2"
    test function-return-string-3 "return string jis0208" -setup {
        testDll function jis0208_return string.jis0208 {}
    } -body {
        jis0208_return
    } -result "\u543e\u543e"
    test function-return-unistring-1 "return unistring" -setup {
        testDll function unistring_return unistring {}
    } -body {
        unistring_return
    } -result "\xe0\xe1\xe2"

    # Other return types are not permitted - test here. Note it does not
    # matter that actual C prototype does not match what we define here since
    # the definition should barf anyways.
    foreach type {binary} {
        test function-return-$type-0 "Return type $type" -body {
            # Prototype does not match C. Does not have to!
            testDll function ${type}_out $type {}
        } -result "Invalid value \"$type\". $errorMessages(typeparsemode)" -returnCodes error
    }
    foreach type {chars unichars bytes} {
        test function-return-$type-0 "Return type $type" -body {
            # Prototype does not match C. Does not have to!
            testDll function string_out ${type}\[2\] {}
        } -result "Invalid value \"$type\[2\]\". $errorMessages(typeparsemode)" -returnCodes error
    }
    test function-return-struct-0 "Return type struct" -body {
        # Prototype does not match C. Does not have to!
        testDll function getTestStruct struct.TestStruct {}
    } -result "Invalid value \"struct.TestStruct\". $errorMessages(typeparsemode)" -returnCodes error


    ###
    # Tests for defaults
    foreach type $intTypes {
        if {$type in $realTypes} {
            set result [list 0.0 1.0]
        } else {
            set result [list 0 1]
        }
        test function-paramdefault-$type-0 "function $type default" -body {
            set fn ${type}_to_$type
            testDll function $fn $type [list x [list $type [list default 1]]]
            list [$fn 0] [$fn]
        } -result [list 0 1]
        test function-paramdefault-error-$type-0 "function $type default - wrong type" -body {
            testDll function ${type}_to_$type $type [list x [list $type [list default 1]]]
            ${type}_to_$type notanumber
        } -result {expected integer but got "notanumber"} -returnCodes error -match glob
    }
    foreach type {string string.utf-8 chars[10] chars.utf-8[10] binary bytes[10]} {
        test function-paramdefault-$type-0 "function $type default" -body {
            set fn string_to_int
            testDll function $fn int [list x [list $type [list default 42]]]
            list [$fn 24] [$fn]
        } -result [list 24 42]
    }

    test function-paramdefault-pointer-0 "Function pointer default" -body {
        set fn pointer_to_pointer
        testDll function $fn {pointer unsafe} [list p [list pointer unsafe [list default [makeptr 42 TAG]]]]
        list [$fn [makeptr 24]] [$fn]
    } -result [list [makeptr 24] [makeptr 42]]
    test function-paramdefault-struct-0 "Function struct default" -setup {
        cffi::Struct create ::S {c uchar ll longlong s short}
    } -body {
        set ll 0x7fffffffffff
        set def [list c 1 ll $ll s 2]
        testDll function structCheck int [list s [list struct.::S byref [list default $def]] c {uchar {default 1}} ll [list longlong [list default $ll]] s {short {default 2}}]
        structCheck
    } -result 1

    test function-paramdefault-0 "function multiargs defaults" -body {
        testDll function threeargs int {a {int {default 0}} b {int {default 10}} c {int {default 100}}}
        list [threeargs] [threeargs 1] [threeargs 1 2] [threeargs 1 2 3]
    } -result {110 111 103 6}
    test function-paramdefault-1 "function multiargs - missing default" -body {
        testDll function threeargs int {a {int {default 0}} b int c {int {default 100}}}
        threeargs 1 2 3
    } -result 6
    test function-paramdefault-error-0 "function multiargs - missing default error" -body {
        testDll function threeargs int {a {int {default 0}} b int c {int {default 100}}}
        threeargs 1
    } -result {Syntax: threeargs a b c} -returnCodes error
    test function-paramdefault-error-1 "function multiargs - missing default error last arg" -body {
        testDll function threeargs int {a {int {default 0}} b {int {default 100}} c int}
        threeargs 1 2
    } -result {Syntax: threeargs a b c} -returnCodes error


    ###
    # Array tests
    foreach type $numericTypes {
        # This matches output of *_array_out function
        foreach count {1 10 10000} {
            set vals [seq 0 $count]; # This matches what *_array_out functions return
            if {$type in $realTypes} {
                set vals [lmap val $vals {expr {double($val)}}]
            }
            set nvals [llength $vals]
            # Skip types that will overflow
            if {$count <= 10 || $type ni {schar uchar short ushort float}} {
                test function-array-$type-$count-in-0 "Array input parameters" -body {
                    testDll function ${type}_array_in $type [list n int arr $type\[$nvals\]]
                    ${type}_array_in $nvals $vals
                } -result [::tcl::mathop::+ {*}$vals]
                test function-array-$type-$count-in-1 "Array input parameters - count greater than arg length" -body {
                    set buflen [expr {$nvals + 1000}]
                    testDll function ${type}_array_in $type [list n int arr $type\[$buflen\]]
                    # Extra slots should have been zeroed
                    ${type}_array_in $buflen $vals
                } -result [::tcl::mathop::+ {*}$vals]
                test function-array-$type-$count-in-4 "Array input parameters - dynamic array" -body {
                    testDll function ${type}_array_in $type [list n int arr $type\[n\]]
                    ${type}_array_in $nvals $vals
                } -result [::tcl::mathop::+ {*}$vals]
                test function-array-$type-$count-in-5 "Array input parameters - dynamic array, array first" -body {
                    testDll function ${type}_array_count_in $type [list arr $type\[n\] n int]
                    ${type}_array_in $nvals $vals
                } -result [::tcl::mathop::+ {*}$vals]

                test function-array-$type-$count-out-0 "Array out parameters" -body {
                    testDll function ${type}_array_out void [list n int arr [list $type\[$nvals\] out]]
                    ${type}_array_out $nvals out
                    set out
                } -result $vals
                test function-array-$type-$count-out-1 "Array out parameters - dynamic array" -body {
                    testDll function ${type}_array_out void [list n int arr [list $type\[n\] out]]
                    ${type}_array_out $nvals out
                    set out
                } -result $vals

                test function-array-$type-$count-inout-0 "Array inout parameters" -body {
                    testDll function ${type}_array_inout void [list n int arr [list $type\[$nvals\] inout]]
                    set out $vals
                    ${type}_array_inout $nvals out
                    set out
                } -result [lmap v $vals {expr {$v+1}}]
                test function-array-$type-$count-inout-1 "Array inout parameters - dynamic array" -body {
                    testDll function ${type}_array_inout void [list n int arr [list $type\[n\] inout]]
                    set out $vals
                    ${type}_array_inout $nvals out
                    set out
                } -result [lmap v $vals {expr {$v+1}}]
            }
        }

        # Tests added for bug#41. Some may duplicate existing tests above
        test function-array-count-$type-0 {Copy array when count param is AFTER array pointer} -setup {
            set fn ${type}_array_count_copy
            testDll function $fn void [list inparam $type\[n_in\] n_in int outparam [list $type\[n_out\] out] n_out int]
        } -body {
            $fn {1 2 3} 3 outarr 2
            set outarr
        } -result [expr {$type in $realTypes ? {1.0 2.0} : {1 2}}]
        test function-count-array-$type-0 {Copy array when count param is BEFORE array pointer} -setup {
            set fn ${type}_count_array_copy
            testDll function $fn void [list n_out int outparam [list $type\[n_out\] out] n_in int inparam $type\[n_in\]]
        } -body {
            $fn 3 outarr 2 {1 2}
            set outarr
        } -result [expr {$type in $realTypes ? {1.0 2.0 0.0} : {1 2 0}}]
        test function-array-count-$type-error-0 {Copy array when count param is AFTER array pointer} -setup {
            set fn ${type}_array_count_copy
            testDll function $fn void [list inparam $type\[n_in\] n_in int outparam [list $type\[n_out\] out] n_out int]
        } -body {
            $fn {1 2 3} 3 outarr -1
            set outarr
        } -result {Value -1 not in range. Must be within [0,2147483647].} -returnCodes error
        test function-array-count-$type-error-1 {Copy array when count param is AFTER array pointer} -setup {
            set fn ${type}_array_count_copy
            testDll function $fn void [list inparam $type\[n_in\] n_in int outparam [list $type\[n_out\] out] n_out int]
        } -body {
            $fn {1 2 3} 0 outarr 2
            set outarr
        } -result {Value 0 not in range. Must be within [0,2147483647].} -returnCodes error
        test function-count-array-$type-error-0 {Copy array when count param is BEFORE array pointer} -setup {
            set fn ${type}_count_array_copy
            testDll function $fn void [list n_out int outparam [list $type\[n_out\] out] n_in int inparam $type\[n_in\]]
        } -body {
            $fn -1 outarr 2 {1 2}
            set outarr
        } -result {Value -1 not in range. Must be within [0,2147483647].} -returnCodes error
        test function-count-array-$type-error-1 {Copy array when count param is BEFORE array pointer} -setup {
            set fn ${type}_count_array_copy
            testDll function $fn void [list n_out int outparam [list $type\[n_out\] out] n_in int inparam $type\[n_in\]]
        } -body {
            $fn 2 outarr 0 {1 2}
            set outarr
        } -result {Value 0 not in range. Must be within [0,2147483647].} -returnCodes error

        # errors
        foreach direc {in out inout} {
            test function-array-$type-$direc-error-0 "Array negative index - $direc" -body {
                testDll function ${type}_array_$direc $type [list n int arr $type\[0\]]
            } -result "Invalid value \"$type\[0\]\". Invalid array size or extra trailing characters." -returnCodes error
            test function-array-$type-$direc-error-1 "Array negative index - $direc" -body {
                testDll function ${type}_array_$direc $type [list n int arr $type\[-1\]]
            } -result "Invalid value \"$type\[-1\]\". Invalid array size or extra trailing characters." -returnCodes error
        }
        test function-array-$type-in-error-2 "Array undefined name index" -body {
            testDll function ${type}_array_in $type [list n int arr $type\[m\]]
            ${type}_array_in $nvals $vals
        } -result {Parameter "m" not found or inaccessible. Could not find referenced count for dynamic array, possibly wrong type or not scalar.} -returnCodes error
        test function-array-$type-in-error-3 "Array index name wrong type" -body {
            testDll function ${type}_array_in $type [list n string arr $type\[n\]]
            ${type}_array_in $nvals $vals
        } -result {Value has the wrong type. Wrong type for dynamic array count value.} -returnCodes error
        test function-array-$type-in-error-4 "Array index name is array" -body {
            testDll function ${type}_array_in $type [list n int\[3\] arr $type\[n\]]
            ${type}_array_in $nvals $vals
        } -result {Parameter "n" not found or inaccessible. Could not find referenced count for dynamic array, possibly wrong type or not scalar.} -returnCodes error
        # "in" not in this loop because function prototype is different
        foreach direc {out inout} {
            test function-array-$type-$direc-error-2 "Array undefined name index - $direc" -body {
                testDll function ${type}_array_$direc $type [list n int arr [list $type\[m\] $direc]]
                ${type}_array_$direc $nvals vals
            } -result {Parameter "m" not found or inaccessible. Could not find referenced count for dynamic array, possibly wrong type or not scalar.} -returnCodes error
            test function-array-$type-$direc-error-3 "Array index name wrong type - $direc" -body {
                testDll function ${type}_array_$direc $type [list n string arr [list $type\[n\] $direc]]
                ${type}_array_$direc $nvals vals
            } -result {Value has the wrong type. Wrong type for dynamic array count value.} -returnCodes error
            test function-array-$type-$direc-error-4 "Array index name is array - $direc" -body {
                testDll function ${type}_array_$direc $type [list n int\[3\] arr [list $type\[n\] $direc]]
                ${type}_array_$direc $nvals vals
            } -result {Parameter "n" not found or inaccessible. Could not find referenced count for dynamic array, possibly wrong type or not scalar.} -returnCodes error
        }
        test function-array-$type-in-typeerror-0 "Array element wrong type - in" -body {
            testDll function ${type}_array_in $type [list n int arr $type\[$nvals\]]
            ${type}_array_in $nvals {0 a 1}
        } -result {expected * but got "a"} -returnCodes error -match glob
        test function-array-$type-inout-typerrror-0 "Array element wrong type - inout" -body {
            testDll function ${type}_array_inout $type [list n int arr [list $type\[$nvals\] inout]]
            ${type}_array_in $nvals {0 a 1}
        } -result {expected * but got "a"} -returnCodes error -match glob
    }


    ###
    # Test error handling with noexcept and output parameters
    # noexcept - with error, without error
    # noexcept storeonerror - with error, without error
    # noexcept storealways - with error, without error
    # except - storeonerror
    # except - storealways
    # also test inout
    proc testexcepts {label comment retannot paramannot expected args} {
        test $label $comment -setup {
            unset -nocomplain outvar
        } -body {
            testDll function string_out [list int {*}$retannot] [list inparam string outparam [list chars\[10\] {*}$paramannot]]
            list \
                [catch {string_out abc outvar} result] \
                $result \
                [expr {[info exists outvar] ? $outvar : 0}]
        } -result $expected
    }
    proc testptrexcepts {label comment ptr retannot paramannot expected args} {
        test $label $comment -setup {
            unset -nocomplain outvar
        } -body {
            testDll function pointer_reflect [list pointer unsafe nonzero {*}$retannot] [list inparam {pointer unsafe} outparam [list pointer unsafe {*}$paramannot]]
            list \
                [catch {pointer_reflect $ptr outvar} result] \
                $result \
                [expr {[info exists outvar] ? $outvar : 0}]
        } -result $expected
    }


    testexcepts function-noexcept-0 "noexcept, no errors" {nonzero noexcept} out [list 0 3 abc]
    testexcepts function-noexcept-1 "except, errors" {zero} out [list 1 {Invalid value "3". Function returned non-zero value.} 0]
    testexcepts function-noexcept-2 "noexcept, errors" {noexcept zero} out [list 0 3 0]
    testptrexcepts function-noexcept-3 "noexcept, no errors" [makeptr 1] {noexcept} out [list 0 [makeptr 1] [makeptr 1]]
    testptrexcepts function-noexcept-4 "except, errors" [makeptr 0] {} out [list 1 "Invalid value \"[makeptr 0]\". Function returned NULL pointer." 0]
    testptrexcepts function-noexcept-5 "noexcept, errors" [makeptr 0] {noexcept} out [list 0 [makeptr 0] 0]

    testexcepts function-storealways-0 "storealways except, no errors" {nonzero} {out storealways} [list 0 3 abc]
    testexcepts function-storealways-1 "storealways except, errors" {zero} {out storealways} [list 1 {Invalid value "3". Function returned non-zero value.} abc]
    testexcepts function-storealways-2 "storealways, noexcept, no errors" {nonzero noexcept} {out storealways} [list 0 3 abc]
    testexcepts function-storealways-3 "storealways noexcept, errors" {noexcept zero} {out storealways} [list 0 3 abc]

    testexcepts function-storeonerror-0 "storeonerror except, no errors" {nonzero} {out storeonerror} [list 0 3 0]
    testexcepts function-storeonerror-1 "storeonerror except, errors" {zero} {out storeonerror} [list 1 {Invalid value "3". Function returned non-zero value.} abc]
    testexcepts function-storeonerror-2 "storeonerror, noexcept, no errors" {nonzero noexcept} {out storeonerror} [list 0 3 0]
    testexcepts function-storeonerror-3 "storeonerror noexcept, errors" {noexcept zero} {out storeonerror} [list 0 3 abc]

    testptrexcepts function-storealways-4 "storealways except, no errors" [makeptr 1] {} {out storealways} [list 0 [makeptr 1] [makeptr 1]]
    testptrexcepts function-storealways-5 "storealways except, errors" [makeptr 0] {} {out storealways} [list 1 "Invalid value \"[makeptr 0]\". Function returned NULL pointer." [makeptr 0]]
    testptrexcepts function-storealways-6 "storealways, noexcept, no errors" [makeptr 1] {noexcept} {out storealways} [list 0 [makeptr 1] [makeptr 1]]
    testptrexcepts function-storealways-7 "storealways noexcept, errors" [makeptr 0] {noexcept} {out storealways} [list 0 [makeptr  0] [makeptr 0]]

    ###
    # enum tests

    foreach type $intTypes {
        test function-enum-$type-0 "function enum $type" -setup {
            cffi::enum delete *
            cffi::enum define E {x 1 a 42}
        } -body {
            set fn ${type}_to_$type
            testDll function $fn $type [list inparam [list $type {enum E}]]
            list [$fn 24] [$fn a]
        } -result [list 24 42]
        test function-enum-$type-1 "function enum $type byref" -setup {
            cffi::enum delete *
            cffi::enum define E {x 1 a 42}
            set fn ${type}_byref
            testDll function $fn $type [list inparam [list $type {enum E} byref]]
        } -body {
            $fn a
        } -result 44
        test function-enum-$type-2 "function enum $type inout" -setup {
            cffi::enum delete *
            cffi::enum define E {x 1 a 42}
            set fn ${type}_inout
            testDll function $fn $type [list inoutparam [list $type {enum E} inout]]
        } -body {
            set param x
            list [$fn param] $param
        } -result {3 2}
        test function-enum-$type-3 "function enum $type array in" -setup {
            cffi::enum delete *
            cffi::enum define E {a 1 b 2}
        } -body {
            testDll function ${type}_array_in $type [list n int arr "$type\[3\] {enum E}"]
            ${type}_array_in 3 {a b 3}
        } -result 6
        test function-enum-$type-4 "function enum $type array inout" -setup {
            cffi::enum delete *
            cffi::enum define E {a 1 b 2}
        } -body {
            testDll function ${type}_array_inout void [list n int arr [list $type\[3\] {enum E} inout]]
            set out {a 3 b}
            ${type}_array_inout 3 out
            set out
        } -result {2 4 3}

        test function-enum-$type-error-0 "function enum $type - missing enum" -setup {
            cffi::enum delete *
        } -body {
            set fn ${type}_to_$type
            testDll function $fn $type [list inparam [list $type {enum E}]]
            $fn a
        } -result {Enum "E" not found or inaccessible. } -returnCodes error
        test function-enum-$type-error-1 "function enum $type - missing enum entry" -setup {
            cffi::enum delete *
            cffi::enum define E {x 1 a 42}
        } -body {
            set fn ${type}_to_$type
            testDll function $fn $type [list inparam [list $type {enum E}]]
            $fn z
        } -result {Enum value "z" not found or inaccessible. } -returnCodes error
        test function-enum-$type-error-2 "function enum $type - wrong type" -setup {
            cffi::enum delete *
            cffi::enum define E {x X a 42}
        } -body {
            set fn ${type}_to_$type
            testDll function $fn $type [list inparam [list $type {enum E}]]
            $fn x
        } -result {expected integer but got "X"} -returnCodes error
    }

    ###
    # bitmask
    foreach type $intTypes {
        test function-bitmask-$type-0 "function bitmask $type" -setup {
            cffi::enum delete *
            cffi::enum define E {a 1 b 2}
        } -body {
            set fn ${type}_to_$type
            testDll function $fn $type [list inparam [list $type bitmask {enum E}]]
            $fn [list a 4 b]
        } -result 7
        test function-bitmask-$type-1 "function bitmask $type byref" -setup {
            cffi::enum delete *
            cffi::enum define E {a 1 b 2}
            set fn ${type}_byref
            testDll function $fn $type [list inparam [list $type bitmask {enum E} byref]]
        } -body {
            $fn {b 4 a}
        } -result 9
        test function-bitmask-$type-2 "function bitmask $type inout" -setup {
            cffi::enum delete *
            cffi::enum define E {a 1 b 2}
            set fn ${type}_inout
            testDll function $fn $type [list inoutparam [list $type {enum E} bitmask inout]]
        } -body {
            set param {4 b a}
            list [$fn param] $param
        } -result {9 8}
    }
}

${NS}::test::testDll destroy

::tcltest::cleanupTests
namespace delete ${NS}::test
