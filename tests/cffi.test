# (c) 2021-2023 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# This file contains basic version and configuration tests

source [file join [file dirname [info script]] common.tcl]

namespace eval ${NS}::test {
    # version
    test version-0 {Version check} -body {
        uplevel #0 package require cffi
    } -result 2.0a0

    # pkgconfig
    test pkgconfig-list-0 {pkgconfig list} -body {
        lsort [cffi::pkgconfig list]
    } -result {backend compiler structbyval version}
    test pkgconfig-get-0 {pkgconfig get version} -body {
        cffi::pkgconfig get version
    } -result [uplevel #0 package require cffi]
    test pkgconfig-get-1 {pkgconfig get compiler} -body {
        catch {cffi::pkgconfig get compiler}
    } -result 0
    test pkgconfig-get-2 {pkgconfig get backend} -body {
        expr {[cffi::pkgconfig get backend] in {libffi dyncall}}
    } -result 1
    test pkgconfig-get-3 {pkgconfig get structbyval} -body {
        pkgconfig get structbyval
    } -result [testConstraint structbyval]; # self testing!

    # limits
    testnumargs limits cffi::limits TYPE
    # Assumes 1/2/4/8 byte integers
    foreach type [array names intMax] {
        test limits-$type-0 "limits $type" -body {
            cffi::limits $type
        } -result [list $intMin($type) $intMax($type)]
    }
    foreach type [concat $voidTypes $realTypes $stringTypes $charArrayTypes $pointerTypes] {
        test limits-$type-error-0 "limits $type - error" -body {
            cffi::limits $type
        } -result {Invalid or non-integral type specified.} -returnCodes error
    }

    # help
    testsubcmd ::cffi::help
    testnumargs help-function "cffi::help function" "NAME" ""
    testnumargs help-functions "cffi::help functions" "" "?PATTERN?"
    testnumargs help-function "cffi::help struct" "NAME" ""
    testnumargs help-function "cffi::help union" "NAME" ""
    test help-function-0 {help no args} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function int_to_int int {}
    } -cleanup {
        rename int_to_int {}
    } -body {
        cffi::help function int_to_int
    } -result "Syntax: int_to_int"
    test help-function-1 {help with args} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function int_to_int int {i int s struct.::TestStruct d {double out}}
    } -cleanup {
        rename int_to_int {}
    } -body {
        cffi::help function int_to_int
    } -result "Syntax: int_to_int i s d\n  i: int in\n  s: struct.::TestStruct in\n  d: double out byref"
    test help-function-2 {help function alias} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function {int_to_int xx} int {i int s struct.::TestStruct d {double out}}
    } -cleanup {
        rename xx {}
    } -body {
        cffi::help function xx
    } -result "Syntax: xx i s d\n  i: int in\n  s: struct.::TestStruct in\n  d: double out byref"
    test help-functions-0 {help functions} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function {int_to_int uu} int {}
        testDll function uint_to_uint int {}
        testDll function uchar_to_uchar int {}
        testDll function schar_to_schar int {}
    } -cleanup {
        rename uu {}
        rename uint_to_uint {}
        rename uchar_to_uchar {}
        rename schar_to_schar {}
    } -body {
        lsort [cffi::help functions u*]
    } -result {uchar_to_uchar uint_to_uint uu}
    test help-functions-1 {help functions no match} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function uint_to_uint int {}
    } -cleanup {
        rename uint_to_uint {}
    } -body {
        lsort [cffi::help functions x*]
    } -result {}
    test help-functions-2 {help functions no match in namespace} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function uint_to_uint int {}
        testDll function uchar_to_uchar int {}
    } -cleanup {
        rename uint_to_uint {}
        rename uchar_to_uchar {}
    } -body {
        list \
        [namespace eval :: {lsort [cffi::help functions u*]}] \
        [lsort [cffi::help functions u*]]
    } -result {{} {uchar_to_uchar uint_to_uint}}
    set desc {struct ::TestStruct
  c: schar
  i: int
  shrt: short
  uint: uint
  ushrt: ushort
  l: long
  uc: uchar
  ul: ulong
  chars: {chars[11]}
  ll: longlong
  unic: {unichars[7]}
  ull: ulonglong
  b: {bytes[3]}
  f: float
  s: struct.::cffi::test::InnerTestStruct
  d: double}
    if {$::tcl_platform(platform) eq "windows"} {
        append desc \n {  wchars: {winchars[13]}}
    }

    test help-functions-3 {help functions no args} -setup {
        # Note bogus params, but no matter, not actually calling
        testDll function uint_to_uint int {}
    } -cleanup {
        rename uint_to_uint {}
    } -body {
        lsort [cffi::help functions]
    } -result {getTestStructSize uint_to_uint}
    test help-struct-0 {help struct} -body {
        cffi::help struct ::TestStruct
    } -result $desc

    test help-union-0 {help union} -body {
        cffi::help union ::TestUnion
    } -result {union ::TestUnion
  i: int
  dbl: double
  uc: uchar}

    # Test interp deletion - just to ensure no crashes
    test interp-deletion-0 "Verify interpreter deletion" -body {
        for {set i 0} {$i < 10} {incr i} {
            set ip [interp create]
            $ip eval [list set testdir [file dirname [info script]]]
            $ip eval {
                set argv ""
                source "$testdir/common.tcl"
                ::cffi::test::testDll function int_to_int int {i int}
                ::cffi::Struct create S {i int}
                ::cffi::alias define INT int
                ::cffi::enum define E {a 1}
            }
            interp delete $ip
        }
    } -result ""

}

::tcltest::cleanupTests
namespace delete cffi::test
