# (c) 2021-2023 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# Contains common definitions across test scripts

source [file join [file dirname [info script]] common.tcl]

namespace eval cffi::test {
    testsubcmd ::cffi::Struct

    test struct-error-0 {Missing argument} -body {
        list [catch {Struct new} result] $result $::errorCode
    } -result {1 {wrong # args: should be "Struct new STRUCTDEF ?-clear? ?-pack N?"} {TCL WRONGARGS}}

    test struct-error-1 {Empty struct definition} -body {
        list [catch {Struct new {}} result] $result $::errorCode
    } -result [list 1 {Invalid value "". Empty definition or missing type for field.} {cffi INVALID_VALUE {Invalid value "". Empty definition or missing type for field.}}]

    test struct-error-2 {Empty struct name} -body {
        list [catch {uplevel #0 {cffi::Struct create "" {i int}}} result] $result $::errorCode
    } -result {1 {Invalid value "". Empty string specified for name.} {cffi INVALID_VALUE {Invalid value "". Empty string specified for name.}}}

    test struct-error-3 {Duplicate field names} -body {
        list [catch {cffi::Struct new {i int i int}} result] $result $::errorCode
    } -result {1 {Field "i" already exists. Field names must be unique.} {cffi EXISTS {Field "i" already exists. Field names must be unique.}}}

    test struct-error-4 {Bad option argument} -body {
        list [catch {Struct new {s int} -foo} result] $result
    } -result {1 {bad option "-foo": must be -clear or -pack}}

    test struct-error-8 {Union mistaken for a struct} -setup {
        cffi::Union create ::U {n int}
    } -cleanup {
        ::U destroy
    } -body {
        cffi::type info struct.::U
    } -result {Struct "::U" not found or inaccessible.} -returnCodes error

    proc teststruct {type} {
        variable errorMessages
        variable unicharSize

        set typeAndAttr $type
        set arrType [list "$type\[2\]"]
        set varsizeArrType [list "$type\[count\]"]
        # Skip scalar tests for these
        if {$type in {chars bytes}} {
            set Size 1
            set Alignment 1
        } elseif {$type eq "unichars"} {
            set Size $unicharSize
            set Alignment $unicharSize
        } elseif {$type eq "winchars"} {
            set Size 2
            set Alignment 2
        } else {
            if {$type eq "pointer"} {
                set typeAndAttr [list $type unsafe]
                set arrType [list $type\[2\] unsafe]
                set varsizeArrType [list $type\[count\] unsafe]
            }

            set tinfo [cffi::type info $type]
            dict with tinfo {}
            set structSize [expr {$Alignment+$Size}]
            test struct-info-$type-0 "struct new $type" -cleanup {
                $s destroy
            } -body {
                set s [cffi::Struct new "fld $type"]
                $s info
            } -result [list Size $Size Alignment $Alignment Flags 0 Fields [list fld [list Size $Size Offset 0 Definition $typeAndAttr]]] -match dict

            test struct-size-$type-0 "struct new $type" -cleanup {
                $s destroy
            } -body {
                set s [cffi::Struct new "fld $type"]
                $s size
            } -result $Size

            test struct-info-$type-1 "struct create {schar $type}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "c schar fld $type"
                S info
            } -result [list Size $structSize Alignment $Alignment Flags 0 Fields [list c [list Size 1 Offset 0 Definition schar] fld [list Size $Size Offset $Alignment Definition $typeAndAttr]]] -match dict

            test struct-size-$type-1 "struct create {schar $type}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "c schar fld $type"
                S size
            } -result $structSize
            test struct-info-$type-2 "struct create {$type uchar}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "fld $type c uchar"
                S info
            } -result [list Size $structSize Alignment $Alignment Flags 0 Fields [list fld [list Size $Size Offset 0 Definition $typeAndAttr] c [list Size 1 Offset $Size Definition uchar] ]] -match dict
            test struct-size-$type-2 "struct create {$type uchar}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "fld $type c uchar"
                S size
            } -result $structSize

            test struct-$type-info-varsize-0 "struct info varsize" -setup {
                cffi::Struct create S "count uchar arr $type\[count\]"
            } -body {
                S info
            } -result {Required option "-vlacount" not specified. This option is required for variable size structs.} -returnCodes error

            test struct-info-varsize-$type-0 "struct create {schar $type\[count\]}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "count schar fld $type\[count\]"
                S info -vlacount 2
            } -result [list \
                        Size [expr {$Alignment + 2*$Size}] \
                        Alignment $Alignment \
                        Flags 2 Fields [list \
                                            count [list Size 1 Offset 0 Definition schar] \
                                            fld [list Size [expr {2*$Size}] Offset $Alignment Definition $varsizeArrType]]]

            test struct-$type-size-varsize-0 "struct size varsize" -setup {
                cffi::Struct create S "count uchar arr $type\[count\]"
            } -body {
                S size
            } -result {Required option "-vlacount" not specified. This option is required for variable size structs.} -returnCodes error

            test struct-size-varsize-$type-0 "struct create {schar $type\[count\]}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "count schar fld $type\[count\]"
                S size -vlacount 2
            } -result [expr {$Alignment+2*$Size}]

        }
        test struct-info-$type-3 "struct create {schar $type\[2\]}" -cleanup {
            S destroy
        } -body {
            cffi::Struct create S "c schar fld $type\[2\] c2 schar"
            S info
        } -result [list \
                       Size [expr {$Alignment+2*$Size+$Alignment}] \
                       Alignment $Alignment \
                       Flags 0 Fields [list \
                                           c [list Size 1 Offset 0 Definition schar] \
                                           fld [list Size [expr {2*$Size}] Offset $Alignment Definition $arrType] \
                                           c2 [list Size 1 Offset [expr {$Alignment+2*$Size}] Definition schar]]]
        test struct-size-$type-3 "struct create {schar $type\[2\]}" -cleanup {
            S destroy
        } -body {
            cffi::Struct create S "c schar fld $type\[2\] c2 schar"
            S size
        } -result [expr {$Alignment+2*$Size+$Alignment}]
    

    }

    # Struct size, offset and alignment tests
    foreach type $baseTypes {
        if {$type in {void binary}} {
            test struct-$type-error-0 "struct create $type" -body {
                cffi::Struct create S "fld $type"
            } -returnCodes error -result "Invalid value \"$type\". $errorMessages(typeparsemode)"
        } else {
            teststruct $type
        }
    }

    test struct-offsets-0 "struct offsets" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set sinfo [::TestStruct info]
        set mismatches [list ]
        if {[getTestStruct s] != [dict get $sinfo Size]} {
            lappend mismatches size
        }
        lappend mismatches {*}[checkTestStruct $s]
    } -result [list]

    test struct-namespace-0 "Verify global struct available in namespace" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.S}
    } -result 4

    test struct-namespace-1 "Verify global struct available in namespace with :: prefix" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.::S}
    } -result 4

    test struct-namespace-2 "Verify struct available in namespace" -cleanup {
        namespace delete ::tempns
    } -body {
        list [namespace eval ::tempns {
            ::cffi::Struct create S {x int}
            cffi::type size struct.S
        }] [::tempns::S name]
    } -result [list 4 ::tempns::S]


    test struct-namespace-3 "Verify qualified struct available in namespace" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.tempnsA::S}
    } -result 4

    test struct-namespace-4 "Verify qualified struct available in namespace with ::" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.::tempnsA::S}
    } -result 4

    test struct-namespace-error-0 "Verify unqualified struct fails" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.S}
    } -result "Struct \"S\" not found or inaccessible." -returnCodes error

    ###
    # struct allocate
    testnumargs struct-allocate "::TestStruct allocate" "" "?-count COUNT? ?-vlacount VLACOUNT?"

    test struct-allocate-0 "struct allocate" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-tag-0 "struct allocate check tag" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        S free $p
        rename S {}
    } -body {
        set p [S allocate]
        cffi::pointer tag $p
    } -result [namespace current]::S

    test struct-allocate-array-0 "struct allocate array" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate 10]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-array-1 "struct allocate array -count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate -count 10]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-array-2 "struct allocate zero count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate 0
    } -result {Value 0 not in range. Must be within [1,2147483647].} -returnCodes error

    test struct-allocate-array-3 "struct allocate negative count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -1
    } -result {Value -1 not in range. Must be within [1,2147483647].} -returnCodes error

    test struct-allocate-array-4 "struct allocate -count 0" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -count 0
    } -result {Value 0 not in range. Must be within [1,2147483647].} -returnCodes error

    test struct-allocate-array-5 "struct allocate -count -1" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -count -1
    } -result {Value -1 not in range. Must be within [1,2147483647].} -returnCodes error

    # allocate varsize structs

    test struct-allocate-varsize-0 "struct allocate" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
    } -result {Required option "-vlacount" not specified. Variable size structs must specify the size of the contained variable length array.} -returnCodes error

    test struct-allocate-varsize-1 "struct allocate -vlacount" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate -vlacount 2]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-varsize-tag-0 "struct allocate check tag" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        S free $p
        rename S {}
    } -body {
        set p [S allocate -vlacount 2]
        cffi::pointer tag $p
    } -result [namespace current]::S

    test struct-allocate-varsize-array-0 "struct allocate array 1" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate 1]
    } -result {Required option "-vlacount" not specified. Variable size structs must specify the size of the contained variable length array.} -returnCodes error

    test struct-allocate-varsize-array-1 "struct allocate -count 1 -vlacount" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate -count 1 -vlacount 2]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-varsize-array-2 "struct allocate -count 1 -vlacount 0" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate -count 1 -vlacount 0]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-varsize-array-3 "struct allocate array" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate 10]
    } -result {Invalid value. Allocation count must 1 for variable sized structs.} -returnCodes error

    test struct-allocate-varsize-array-4 "struct allocate array -count" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate -count 10 -vlacount 2]
    } -result {Invalid value. Allocation count must 1 for variable sized structs.} -returnCodes error

    test struct-allocate-varsize-array-5 "struct allocate zero count" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -count 0 -vlacount 2
    } -result {Value 0 not in range. Must be within [1,2147483647].} -returnCodes error

    test struct-allocate-varsize-array-6 "struct allocate negative vlacount" -setup {
        cffi::Struct create S {count int values int[count]}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -vlacount -1
    } -result {Value -1 not in range. Must be within [0,2147483647].} -returnCodes error

    ###
    # struct free
    testnumargs struct-free "::TestStruct free" "POINTER" ""
    test struct-free-0 "struct free" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [S free $p] \
            [catch {S free $p} result] \
            [string match "Invalid value \"$p\". Pointer validation failed: not registered." $result]
    } -result [list {} 1 1]

    test struct-free-1 "struct free NULL pointer" -setup {
        cffi::Struct create ::S {x int}
    } -cleanup {
        rename ::S {}
    } -body {
        ::S free 0^::S
    } -result ""

    ###
    # struct fromnative
    testnumargs struct-fromnative "::TestStruct fromnative" "POINTER" "?INDEX?"

    test struct-fromnative-0 "struct fromnative" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.::TestStruct}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative-1 "struct fromnative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.::S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    test struct-fromnative-error-0 "struct fromnative - unsafe pointer" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.TestStruct}
    } -cleanup {
        cffi::pointer safe $p
        TestStruct free $p
    } -body {
        cffi::pointer dispose $p
        set s [::TestStruct fromnative $p]
    } -result {^Invalid value "0x[[:xdigit:]]+\^::TestStruct". Pointer validation failed: not registered.$} -match regexp -returnCodes error

    test struct-fromnative-error-1 "struct fromnative - null pointer" -body {
        ::TestStruct fromnative NULL
    } -result "*Pointer is NULL*" -match glob -returnCodes error

    test struct-fromnative-varsize-0 "struct fromnative - varsize" -setup {
        cffi::Struct create S {n int d double[n]}
        set p [S new {n 2 d {1 2}}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S fromnative $p
    } -result {n 2 d {1.0 2.0}}

    test struct-fromnative-varsize-1 "struct fromnative - varsize - zero count" -setup {
        cffi::Struct create S {n int d double[n]}
        set p [S new {n 0 d {1 2}}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S fromnative $p
    } -result {n 0 d {}}

    test struct-fromnative-varsize-2 "struct fromnative - varsize - nested" -setup {
        cffi::Struct create S {n int d double[n]}
        cffi::Struct create T {i uchar s struct.S}
        set p [T new {i 42 s {n 2 d {1 2}}}]
    } -cleanup {
        T free $p
        T destroy
        S destroy
    } -body {
        T fromnative $p
    } -result {i 42 s {n 2 d {1.0 2.0}}}

    ###
    # fromnative!
    testnumargs struct-fromnative! "::TestStruct fromnative!" "POINTER" "?INDEX?"

    test struct-fromnative!-0 "struct fromnative!" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p {pointer.::TestStruct unsafe}}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative! $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative!-1 "struct fromnative! index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.::S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative! $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    test struct-fromnative!-2 "struct fromnative! - unsafe" -setup {
        set p [TestStruct allocate]
        cffi::pointer dispose $p ;# Make unsafe
        testDll function getTestStruct int {p {pointer.::TestStruct unsafe}}
    } -cleanup {
        cffi::pointer safe $p ;# Before freeing
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative! $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative!-error-0 "struct fromnative! - null pointer" -body {
        ::TestStruct fromnative! NULL
    } -result "*Pointer is NULL*" -match glob -returnCodes error

    test struct-fromnative!-varsize-0 "struct fromnative - varsize" -setup {
        cffi::Struct create S {n int d double[n]}
        set p [S new {n 2 d {1 2}}]
        cffi::pointer dispose $p ;# Make unsafe
    } -cleanup {
        cffi::pointer safe $p ;# Before freeing
        S free $p
        S destroy
    } -body {
        S fromnative! $p
    } -result {n 2 d {1.0 2.0}}

    test struct-fromnative!-varsize-1 "struct fromnative - varsize - zero count" -setup {
        cffi::Struct create S {n int d double[n]}
        set p [S new {n 0 d {1 2}}]
        cffi::pointer dispose $p ;# Make unsafe
    } -cleanup {
        cffi::pointer safe $p ;# Before freeing
        S free $p
        S destroy
    } -body {
        S fromnative! $p
    } -result {n 0 d {}}

    test struct-fromnative!-varsize-2 "struct fromnative! - varsize - nested" -setup {
        cffi::Struct create S {n int d double[n]}
        cffi::Struct create T {i uchar s struct.S}
        set p [T new {i 42 s {n 2 d {1 2}}}]
        cffi::pointer dispose $p ;# Make unsafe
    } -cleanup {
        cffi::pointer safe $p ;# Before freeing
        T free $p
        T destroy
        S destroy
    } -body {
        T fromnative! $p
    } -result {i 42 s {n 2 d {1.0 2.0}}}

    ###
    # struct tonative
    testnumargs struct-tonative "::TestStruct tonative" "POINTER INITIALIZER" "?INDEX?"
    test struct-tonative-0 "struct tonative" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3}] [S fromnative $p]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-1 "struct tonative scalar" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3} 0] [S fromnative $p 0]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-2 "struct tonative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate 3]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c 4 i 5 s 6} 1
        S tonative $p {c 1 i 2 s 3} 0
        S tonative $p {c 7 i 8 s 9} 2
        list [S fromnative $p 0] [S fromnative $p 1] [S fromnative $p 2]
    } -result {{c 1 i 2 s 3} {c 4 i 5 s 6} {c 7 i 8 s 9}}

    test struct-tonative-3 "struct tonative different field order" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {i 2 s 3 c 1}
        S fromnative $p 0
    } -result {c 1 i 2 s 3}

    test struct-tonative-4 "struct with winchars multisz" -setup {
        cffi::Struct create S {w {winchars[10] multisz}}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -constraints win -body {
        S tonative $p [list w [list {a b} cd e]]
        S fromnative $p
    } -result [list w [list {a b} cd e]]

    test struct-tonative-4.a "struct with winchars multisz - error" -setup {
        cffi::Struct create S {w {winchars[9] multisz}}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -constraints win -body {
        S tonative $p [list w [list {a b} cd e]]
    } -result {Invalid value "{a b} cd e". String length is greater than specified maximum buffer size. Error converting field ::cffi::test::S.w to a native value.} -returnCodes error

    test struct-tonative-error-0 "struct tonative bad value" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S new {c 0 i 1 s 2}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {c 10 i x s 11}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {expected integer but got "x" Error converting field ::S.i to a native value.} {c 0 i 1 s 2}]

    test struct-tonative-error-1 "struct tonative missing field" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S new {c 0 i 1 s 2}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {c 10 i 11}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {Struct field "s" not found or inaccessible. Field missing in struct dictionary value. Error converting field ::S.s to a native value.} {c 0 i 1 s 2}]

    test struct-tonative-error-2 "struct tonative chars overflow" -setup {
        cffi::Struct create ::S {i int c chars[3]}
        set p [::S new {i 0 c ab}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {i 42 c abcd}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {Invalid value "abcd". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} {i 0 c ab}]

    test struct-tonative-error-6 "struct tonative unichars overflow" -setup {
        cffi::Struct create ::S {i int c unichars[3]}
        set p [::S new {i 0 c ab}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {i 42 c abcd}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {Invalid value "abcd". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} {i 0 c ab}]

    test struct-tonative-error-6.winchars "struct tonative winchars overflow" -setup {
        cffi::Struct create ::S {i int c winchars[3]}
        set p [::S new {i 0 c ab}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {i 42 c abcd}} emsg] $emsg [S fromnative $p]
    } -constraints win -result [list 1 {Invalid value "abcd". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} {i 0 c ab}]


    test struct-tonative-error-7 "struct tonative bytes overflow" -setup {
        cffi::Struct create ::S {c bytes[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value. Byte array length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-tonative-error-8 "struct tonative - struct with strings" -body {
        set p [StructWithStrings allocate]
        StructWithStrings tonative $p [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context. Error converting field ::StructWithStrings.s to a native value.} -returnCodes error

    test struct-tonative-error-9 "struct tonative - unsafe pointer" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
        cffi::pointer dispose $p
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        rename S ""
    } -body {
        S tonative $p {c 1 i 2 s 3}
    } -result {^Invalid value "0x[[:xdigit:]]+\^::S"\. Pointer validation failed: not registered.$} -match regexp -returnCodes error

    test struct-tonative-error-10 "struct tonative - NULL pointer" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S tonative NULL {c 1 i 2 s 3}
    } -result {*Pointer is NULL*} -match glob -returnCodes error

    test struct-tonative-varsize-0 "struct tonative varsize" -setup {
        set vlacount 2
        cffi::Struct create ::S {n uchar d double[n]}
        set p [::S allocate -vlacount $vlacount]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        set structVal [list n $vlacount d {42 43}]
        S tonative $p $structVal
    } -result {Operation tonative failed on ::S. Operation not permitted on variable sized structs.} -returnCodes error

    test struct-tonative-varsize-1 "struct tonative - varsize - nested" -setup {
        cffi::Struct create S {n int d double[n]}
        cffi::Struct create T {i uchar s struct.S}
        set p [T allocate -vlacount $vlacount]
    } -cleanup {
        T free $p
        T destroy
        S destroy
    } -body {
        T tonative $p {i 42 s {n 2 d {1 2}}}
    } -result {Operation tonative failed on ::cffi::test::T. Operation not permitted on variable sized structs.} -returnCodes error

    ###
    # struct tonative!
    testnumargs struct-tonative! "::TestStruct tonative!" "POINTER INITIALIZER" "?INDEX?"
    test struct-tonative!-0 "struct tonative" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
        cffi::pointer dispose $p
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        rename S ""
    } -body {
        list [S tonative! $p {c 1 i 2 s 3}] [S fromnative! $p]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative!-error-0 "struct tonative! - NULL pointer" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S tonative! NULL {c 1 i 2 s 3}
    } -result {*Pointer is NULL*} -match glob -returnCodes error

    test struct-tonative!-varsize-0 "struct tonative! varsize" -setup {
        set vlacount 2
        cffi::Struct create ::S {n uchar d double[n]}
        set p [::S allocate -vlacount $vlacount]
        cffi::pointer dispose $p
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        rename S ""
    } -body {
        set structVal [list n $vlacount d {42 43}]
        S tonative! $p $structVal
    } -result {Operation tonative failed on ::S. Operation not permitted on variable sized structs.} -returnCodes error

    ###
    # struct describe
    # Hardcoded - fix TBD
    testnumargs struct-describe "::TestStruct describe"
    test struct-describe-0 "struct describe" -constraints disabled -body {
        regsub -all {\s+} [TestStruct describe] " "
    } -result [regsub -all {\s+} {Struct TestStruct nRefs=1 size=128 alignment=8 nFields=16
        schar c offset=0 size=1
        int i offset=4 size=4
        short shrt offset=8 size=2
        uint ui offset=12 size=4
        ushort ushrt offset=16 size=2
        long l offset=20 size=4
        uchar uc offset=24 size=1
        ulong ul offset=28 size=4
        chars c3[13] offset=32 size=13
        longlong ll offset=48 size=8
        unichars unic[13] offset=56 size=26
        ulonglong ull offset=88 size=8
        bytes b[3] offset=96 size=3
        float f offset=100 size=4
        struct cffi::test::InnerTestStruct s offset=104 size=15
        double d offset=120 size=8} " "]

    test struct-describe-varsize-0 "struct describe - varsize" -setup {
        cffi::Struct create S {n int d double[n]}
    } -cleanup {
        S destroy
    } -body {
        regsub -all {\s+} [S describe] " "
    } -result {Struct ::cffi::test::S nRefs=1 size=8 alignment=8 flags=2 nFields=2 int n offset=0 size=4 double d[n] offset=8 size=0}

    test struct-describe-varsize-1 "struct describe - varsize - nested" -setup {
        cffi::Struct create S {n int d double[n]}
        cffi::Struct create T {i uchar s struct.S}
    } -cleanup {
        T destroy
        S destroy
    } -body {
        regsub -all {\s+} [T describe] " "
    } -result {Struct ::cffi::test::T nRefs=1 size=16 alignment=8 flags=2 nFields=2 uchar i offset=0 size=1 struct ::cffi::test::S s offset=8 size=8}


    ###
    # tobinary/frombinary
    testnumargs struct-tobinary "::TestStruct tobinary" "DICTIONARY"
    testnumargs struct-frombinary "::TestStruct frombinary" "BINARY"

    test struct-tobinary-0 "struct tobinary" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct s
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set b [TestStruct tobinary $s]
        list [string length $b] [checkTestStruct [TestStruct frombinary $b]]
    } -result [list $testStructSize {}]

    test struct-tobinary-1 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        if {$::tcl_platform(pointerSize) == 4} {
            set scanner n
        } else {
            set scanner m
        }
        binary scan $bin ${scanner}3 result
        set result
    } -result {1 2 3}

    test struct-tobinary-2 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        S frombinary $bin
    } -result [list ptrs [make_unsafe_pointers 1 2 3]]

    test struct-tobinary-3 "struct with winchars multisz" -cleanup {
        S destroy
    } -constraints win -body {
        cffi::Struct create S {w {winchars[10] multisz}}
        set bin [S tobinary [list w [list {a b} cd e]]]
        S frombinary $bin
    } -result [list w [list {a b} cd e]]

    test struct-tobinary-3.a "struct with winchars multisz - error" -cleanup {
        S destroy
    } -constraints win -body {
        cffi::Struct create S {w {winchars[9] multisz}}
        set bin [S tobinary [list w [list {a b} cd e]]]
    } -result {Invalid value "{a b} cd e". String length is greater than specified maximum buffer size. Error converting field ::cffi::test::S.w to a native value.} -returnCodes error

    test struct-tobinary-error-0 "struct tobinary missing field" -setup {
        cffi::Struct create ::S {x int y int}
    } -body {
        S tobinary {x 0}
    } -result {Struct field "y" not found or inaccessible. Field missing in struct dictionary value. Error converting field ::S.y to a native value.} -returnCodes error

    test struct-tobinary-error-1 "struct tobinary - struct with strings" -body {
        StructWithStrings tobinary [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context. Error converting field ::StructWithStrings.s to a native value.} -returnCodes error

    test struct-frombinary-error-0 "struct frombinary truncated" -setup {
        catch {::S destroy}
        cffi::Struct create ::S {x int y int}
        set b [S tobinary {x 0 y 1}]
    } -cleanup {
        rename S ""
    } -body {
        S frombinary [string range $b 0 end-1]
    } -result {Invalid value. Truncated structure binary value.} -returnCodes error

    test struct-tobinary-varsize-0 "struct tobinary/frombinary varsize" -setup {
        cffi::Struct create S {n short ll longlong[n]}
    } -cleanup {
        S destroy
    } -body {
        set bin [S tobinary [list n 2 ll [list $intMin(longlong) $intMax(longlong)]]]
        S frombinary $bin
    } -result [list n 2 ll [list $intMin(longlong) $intMax(longlong)]]

    test struct-tobinary-varsize-1 "struct tobinary/frombinary varsize" -setup {
        cffi::Struct create S {n short ll longlong[n]}
        cffi::Struct create T {i int s struct.S}
    } -cleanup {
        T destroy
        S destroy
    } -body {
        set bin [T tobinary [list i 42 s [list n 2 ll [list $intMin(longlong) $intMax(longlong)]]]]
        T frombinary $bin
    } -result [list i 42 s [list n 2 ll [list $intMin(longlong) $intMax(longlong)]]]

    test struct-tobinary-varsize-2 "struct tobinary/frombinary varsize = 0" -setup {
        cffi::Struct create S {n short ll longlong[n]}
    } -cleanup {
        S destroy
    } -body {
        set bin [S tobinary {n 0 ll {}}]
        S frombinary $bin
    } -result {n 0 ll {}}


    test struct-frombinary-varsize-0 "struct frombinary truncation - less than minsize" -setup {
        cffi::Struct create S {n short ll longlong[n]}
    } -cleanup {
        S destroy
    } -body {
        set bin [S tobinary [list n 2 ll [list $intMin(longlong) $intMax(longlong)]]]
        S frombinary [string range $bin 0 6]
    } -result {Invalid value. Truncated structure binary value.} -returnCodes error

    test struct-frombinary-varsize-1 "struct frombinary truncation - greater than minsize" -setup {
        cffi::Struct create S {n short ll longlong[n]}
    } -cleanup {
        S destroy
    } -body {
        set bin [S tobinary [list n 2 ll [list $intMin(longlong) $intMax(longlong)]]]
        S frombinary [string range $bin 0 end-1]
    } -result {Invalid value. Truncated structure binary value.} -returnCodes error

    ###
    # struct name

    test struct-name-0 "struct name in namespace" -setup {
        cffi::Struct create S {x int y int}
    } -body {
        # Name should not have leading ::
        S name
    } -result "::cffi::test::S"

    ###
    # Aliases in structs

    test struct-alias-0 "struct field alias" -setup {
        cffi::alias define Pointer {pointer unsafe}
        cffi::Struct create S {x int p Pointer}
    } -body {
        S info
    } -result "Size [expr {2*$::tcl_platform(pointerSize)}] Alignment $::tcl_platform(pointerSize) Flags 0 Fields {x {Size 4 Offset 0 Definition int} p {Size $::tcl_platform(pointerSize) Offset $::tcl_platform(pointerSize) Definition {pointer unsafe}}}"

    test struct-alias-1 "struct field array alias" -setup {
        cffi::alias define Array {int[4]}
        cffi::Struct create S {x schar a Array}
    } -body {
        S info
    } -result {Size 20 Alignment 4 Flags 0 Fields {x {Size 1 Offset 0 Definition schar} a {Size 16 Offset 4 Definition {{int[4]}}}}}


    ###
    # pointer handling in fields
    test struct-pointer-novaluechecks-0 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer novaluechecks unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]

    test struct-pointer-novaluechecks-1 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result {Invalid value. Pointer is NULL. Error converting field ::cffi::test::S.p to a native value.} -returnCodes error

    test struct-pointer-novaluechecks-2 "NULL pointer in output field" -body {
        cffi::Struct create S {p {pointer novaluechecks unsafe}}
        cffi::Struct create S2 {p {pointer unsafe}}
        S2 frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]


    ###
    # struct field defaults
    # Note: struct tobinary does not support string/unistring/winstring. Those will have
    # to be covered in function.test
    set matrix {
        schar -1 uchar 1 short -2 ushort 2 int -3 uint 3 long -4 ulong 4
        longlong -5 ulonglong 5 float 0.5 double 1.5
        chars[3] ab unichars[3] de
    }
    if {[onwindows]} {
        lappend matrix {winchars[3]} fg
    }

    foreach {type val} $matrix {
        test struct-field-default-$type-0 "$type field with default" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld $val]

        test struct-field-default-$type-0 "$type field with default -arg supplied" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {fld 42}]
        } -cleanup {
            $s destroy
        } -result [list fld [expr {$type in $realTypes ? 42.0 : 42}]]
    }

    test struct-field-default-varsize-0 "struct field default - varsize" -setup {
        cffi::Struct create S {n int d {double[n] {default {3 4}}}}
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set p [S new {n 2}]
        S fromnative $p
    } -result {n 2 d {3.0 4.0}}

    test struct-field-default-varsize-1 "struct field default - varsize - extra elems" -setup {
        cffi::Struct create S {n int d {double[n] {default {3 4 5}}}}
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set p [S new {n 2}]
        S fromnative $p
    } -result {n 2 d {3.0 4.0}}

    test struct-field-default-varsize-2 "struct field default - varsize - fewer elems" -setup {
        cffi::Struct create S {n int d {double[n] {default {3 4}}}}
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set p [S new {n 3}]
        S fromnative $p
    } -result {n 3 d {3.0 4.0 0.0}}

    test struct-field-default-varsize-3 "struct field default - varsize - count cannot be defaulted" -setup {
        cffi::Struct create S {n {int {default 2}} d double[n]}
    } -cleanup {
        S destroy
    } -body {
        set p [S new {d {1 2}}]
    } -result {Invalid value "n". No value supplied for dynamic field count.} -returnCodes error

    ###
    # Struct field structsize annotation
    foreach {type val} {
        schar uchar short ushort int uint long ulong longlong ulonglong
    } {
        test struct-field-structsize-$type-0 "$type field structsize" -body {
            set s [cffi::Struct new [list fld [list $type structsize]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld [dict get [cffi::type info $type] Size]]
    }
    set matrix {float double pointer chars[2] unichars[2] string unistring binary struct.::TestStruct}
    if {[onwindows]} {
        lappend matrix winstring {winchars[2]}
    }
    foreach type $matrix {
        test struct-field-structsize-$type-error-0 "$type field structsize" -body {
            cffi::Struct new [list fld [list $type structsize]]
        } -result "Invalid value \"[list $type] structsize\". $errorMessages(attrtype)" -returnCodes error
    }

    test struct-field-structsize-default "structsize with default" -body {
        cffi::Struct new {dw {uint structsize {default 0}}}
    } -result {Invalid value "uint structsize {default 0}". Defaults are not allowed in this declaration context.} -returnCodes error

    test struct-field-structsize-default "two structsize fields" -body {
        cffi::Struct new {dw {uint structsize} dw2 {uint structsize}}
    } -result {Invalid value "uint structsize". A struct cannot have a multiple fields with the structsize annotation.} -returnCodes error

    ###
    # -clear option
    test struct-clear-0 "struct create -clear" -body {
        cffi::Struct create S {i int j int k {int {default 2}}} -clear
        S frombinary [S tobinary {j 1}]
    } -cleanup {
        S destroy
    } -result {i 0 j 1 k 2}

    test struct-clear-1 "struct new -clear" -body {
        set s [cffi::Struct new {i int j {int {default 1}} k int} -clear]
        $s frombinary [$s tobinary {}]
    } -cleanup {
        $s destroy
    } -result {i 0 j 1 k 0}

    test struct-clear-varsize-0 "struct clear varsize" -setup {
        cffi::Struct create S {n int d double[n]} -clear
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set p [S new {n 3}]
        S fromnative $p
    } -result {n 3 d {0.0 0.0 0.0}}

    test struct-clear-varsize-1 "struct clear varsize" -setup {
        cffi::Struct create S {n int d double[n]} -clear
    } -cleanup {
        S destroy
    } -body {
        set p [S new {}]
    } -result {Invalid value "n". No value supplied for dynamic field count.} -returnCodes error

    ###
    # enum and bitmask
    test struct-enum-0 "struct field enum" -setup {
        cffi::enum define E {A 1 B 42}
    } -body {
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i B}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i 42}
    test struct-enum-1 "struct field enum with bitmask" -setup {
        cffi::enum define E {A 1 B 2}
    } -body {
        cffi::Struct create S {i {int {enum E} bitmask}}
        S frombinary [S tobinary {i {A B 4}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i 7}
    test struct-enum-2 "struct field enum array with bitmask" -setup {
        cffi::enum define E {A 1 B 2 C 4}
    } -body {
        cffi::Struct create S {i {int[3] {enum E} bitmask}}
        S frombinary [S tobinary {i {A {B C} {A 8}}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i {1 6 9}}
    test struct-enum-error-0 "struct field num with unknown enum" -body {
        cffi::Struct create S {i {int {enum NOSUCHENUM}}}
    } -result {Enum "NOSUCHENUM" not found or inaccessible.} -returnCodes error
    test struct-enum-error-1 "struct field num with unknown enum value" -body {
        cffi::enum define E {A 1 B 2 C 4}
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i X}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {expected integer but got "X" Error converting field ::cffi::test::S.i to a native value.} -returnCodes error

    ###
    # Scope tests
    test struct-enum-scope-0 "struct field enum - local scope" -setup {
        cffi::enum delete *
        namespace eval :: {
            cffi::enum delete *
            cffi::enum define E {A 0}
        }
        namespace eval ::ns {
            cffi::enum delete *
            cffi::enum define E {A 1}
        }
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i {int {enum E}}}]
        S frombinary [S tobinary {i A}]
    } -cleanup {
        S destroy
    } -result {i 1}
    test struct-enum-scope-1 "struct field enum - local fall back to global" -setup {
        cffi::enum delete *
        namespace eval :: {
            cffi::enum delete *
            cffi::enum define E {A 0}
        }
        namespace eval ::ns {cffi::enum delete *}
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i {int {enum E}}}]
        S frombinary [S tobinary {i A}]
    } -cleanup {
        S destroy
    } -result {i 0}

    test struct-alias-scope-0 "struct field alias - local scope" -setup {
        cffi::alias delete *
        namespace eval :: {
            cffi::alias delete *
            cffi::alias define INT uchar
        }
        namespace eval ::ns {
            cffi::alias delete *
            cffi::alias define INT int
        }
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i INT}]
        # Would error out if global INT was used
        S frombinary [S tobinary {i 256}]
    } -cleanup {
        S destroy
    } -result {i 256}

    ###
    # fieldpointer
    testnumargs struct-fieldpointer "::TestStruct fieldpointer" "POINTER FIELD" "?TAG? ?INDEX?"

    test struct-fieldpointer-0 "Address of first field in struct" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr c
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [makeptr 8]

    test struct-fieldpointer-1 "Address of non-first field in struct, tag" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr i TAG]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 12 TAG] 0]

    test struct-fieldpointer-2 "Address of field in struct, tag, index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr i TAG 2]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 28 TAG] 0]
    test struct-fieldpointer-3 "Address of field in struct, no tag, index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr c "" 1]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 16] 0]

    test struct-fieldpointer-error-0 "Address of invalid field name" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr nosuchfield
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    test struct-fieldpointer-error-1 "Address of field - invalid index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr i TAG -1
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result {Value -1 not in range. Must be within [0,2147483647].} -returnCodes error
    test struct-fieldpointer-error-2 "Address of field - wrong pointer type" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S2]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr i
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result "Value \"[scoped_ptr 8 S2]\" has the wrong type. Expected pointer to ::cffi::test::S." -returnCodes error

    test struct-fieldpointer-error-3 "Address of field - unsafe pointer" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
    } -body {
        S fieldpointer $ptr i
    } -cleanup {
        S destroy
    } -result "Invalid value \"[scoped_ptr 8 S]\". Pointer validation failed: not registered." -returnCodes error

    ###
    # struct getnative
    testnumargs struct-getnative "::TestStruct getnative" "POINTER FIELD" "?INDEX?"
    test struct-getnative-0 "Getnative each field struct" -setup {
        testDll function getTestStruct int {p pointer.::TestStruct}
        set p [::TestStruct allocate]
        getTestStruct $p
        unset -nocomplain testval
    } -cleanup {
        ::TestStruct free $p
    } -body {
        dict for {name -} [dict get [::TestStruct info] Fields] {
            lappend testval $name [::TestStruct getnative $p $name]
        }
        checkTestStruct $testval
    } -result ""
    test struct-getnative-1 "getnative pointer field with tag" -setup {
        ::cffi::Struct create S {c schar i int p pointer.S}
        set p [S allocate]
        S tonative $p [list c 1 i 2 p $p]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [S getnative $p c] [S getnative $p i] [string equal $p [S getnative $p p]]
    } -result {1 2 1}
    test struct-getnative-2 "getnative at index" -setup {
        ::cffi::Struct create S {c schar d double}
        set p [S allocate 2]
        S tonative $p [list c 1 d 2]
        S tonative $p [list c 10 d 20] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list \
            [S getnative $p c] [S getnative $p d] \
            [S getnative $p c 1] [S getnative $p d 1]
    } -result {1 2.0 10 20.0}
    test struct-getnative-3 "getnative pointer safety - struct pointer field always unsafe" -setup {
        ::cffi::Struct create S {p pointer}
        set p [S allocate]
        # Note no need to initialize allocation
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set ptrval [S getnative $p p]
        cffi::pointer isvalid $ptrval
    } -result 0
    test struct-getnative-4 "getnative pointer safety - unsafe" -setup {
        ::cffi::Struct create S {p {pointer unsafe}}
        set p [S allocate]
        # Note no need to initialize allocation
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set ptrval [S getnative $p p]
        cffi::pointer isvalid $ptrval
    } -result 0
    test struct-getnative-error-0 "Unsafe pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S getnative [scoped_ptr 1 S] i
    } -result "Invalid value \"[scoped_ptr 1 S]\". Pointer validation failed: not registered." -returnCodes error
    test struct-getnative-error-1 "Wrong tag pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S getnative [scoped_ptr 1 S2] i
    } -result "Value \"[scoped_ptr 1 S2]\" has the wrong type. Expected pointer to ::cffi::test::S." -returnCodes error
    test struct-getnative-error-2 "NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S getnative NULL i
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test struct-getnative-error-3 "getnative invalid field name" -setup {
        ::cffi::Struct create S {c schar}
        set p [S allocate]
        S tonative $p [list c 1]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnative $p nosuchfield
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    test struct-getnative-varsize-0 "struct getnative - varsize" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 2 d { 2 3}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnative $p d
    } -result {2.0 3.0}

    test struct-getnative-varsize-1 "struct getnative - nested varsize" -setup {
        cffi::Struct create ::S {n int d double[n]}
        cffi::Struct create ::T {i int s struct.S}
        set p [::T new {i 42 s {n 2 d { 2 3}}}]
    } -cleanup {
        ::T free $p
        rename ::T ""
        rename ::S ""
    } -body {
        ::T getnative $p s
    } -result {n 2 d {2.0 3.0}}

    test struct-getnative-varsize-2 "struct getnative - varsize index 0" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 2 d { 2 3}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnative $p d 0
    } -result {2.0 3.0}

    test struct-getnative-varsize-2 "struct getnative - varsize index 1" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 2 d { 2 3}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnative $p d 1
    } -result {Operation indexing failed on ::S. Operation not permitted on variable sized structs.} -returnCodes error

    test struct-getnative-varsize-3 "struct getnative - varsize = 0" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 0 d {}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnative $p d
    } -result {}

    ###
    # getnative!
    testnumargs struct-getnative! "::TestStruct getnative!" "POINTER FIELD" "?INDEX?"
    test struct-getnative!-0 "Getnative! each field struct" -setup {
        testDll function getTestStruct int {p pointer.::TestStruct}
        set p [::TestStruct allocate]
        getTestStruct $p
        cffi::pointer dispose $p
        unset -nocomplain testval
    } -cleanup {
        cffi::pointer safe $p
        ::TestStruct free $p
    } -body {
        dict for {name -} [dict get [::TestStruct info] Fields] {
            lappend testval $name [::TestStruct getnative! $p $name]
        }
        checkTestStruct $testval
    } -result ""

    ###
    # struct setnative

    testnumargs struct-setnative "::TestStruct setnative" "POINTER FIELD VALUE" "?INDEX?"
    test struct-setnative-0 "Setnative each field struct" -setup {
        set p [::TestStruct allocate]
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct ts
    } -cleanup {
        ::TestStruct free $p
    } -body {
        dict for {key val} $ts {
            ::TestStruct setnative $p $key $val
        }
        checkTestStruct [::TestStruct fromnative $p]
    } -result ""
    test struct-setnative-1 "setnative pointer field with tag" -setup {
        ::cffi::Struct create S {c schar p pointer.S}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p c 42
        S setnative $p p $p
        list [S getnative $p c] [string equal $p [S getnative $p p]]
    } -result {42 1}
    test struct-setnative-2 "setnative at index" -setup {
        ::cffi::Struct create S {c schar d double}
        set p [S allocate 2]
        S tonative $p [list c 1 d 2]
        S tonative $p [list c 10 d 20] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p c 100 1
        S setnative $p d 200 1
        list [S fromnative $p] [S fromnative $p 1]
    } -result {{c 1 d 2.0} {c 100 d 200.0}}
    test struct-setnative-3 "setnative pointer safety - unsafe" -setup {
        ::cffi::Struct create S {p {pointer unsafe}}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p p [makeptr 1]
        set ptrval [S getnative $p p]
        list $ptrval [cffi::pointer isvalid $ptrval]
    } -result [list [makeptr 1] 0]
    test struct-setnative-error-0 "Unsafe pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative [scoped_ptr 1 S] i 42
    } -result "Invalid value \"[scoped_ptr 1 S]\". Pointer validation failed: not registered." -returnCodes error
    test struct-setnative-error-1 "Wrong tag pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative [scoped_ptr 1 S2] i 42
    } -result "Value \"[scoped_ptr 1 S2]\" has the wrong type. Expected pointer to ::cffi::test::S." -returnCodes error
    test struct-setnative-error-2 "NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative NULL i 42
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test struct-setnative-error-3 "setnative invalid field name" -setup {
        ::cffi::Struct create S {c schar}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p nosuchfield 1
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error
    set testnum -1
    set testvals {
        c 256 i notanint shrt 100000 uint -1 ushrt -1 l notanint uc -1 ul -1 chars toolongastring ll notanint unic toolongastring ull -1 b morethan3bytes f notanumber s {unknownfield 104} d notanumber
    }
    if {[onwindows]} {
        lappend testvals wchars toolongastring
    }
    foreach {fld val} $testvals {
        test struct-setnative-value-error-$fld "Setnative field struct bad $fld value" -setup {
            set p [::TestStruct allocate]
            testDll function getTestStruct int {p pointer.::TestStruct}
            getTestStruct $p
        } -cleanup {
            ::TestStruct free $p
        } -body {
            list [catch {::TestStruct setnative $p $fld $val} result] \
                [regexp {not in range|expected.*but got|greater than.*maximum buffer|Field missing} $result] [checkTestStruct [::TestStruct fromnative $p]]
        } -result {1 1 {}}
    }

    test struct-setnative-varsize-0 "setnative varsize struct on field other than count and vla" -setup {
        cffi::Struct create S {u uchar n {int {default 2}} d double[n]}
        set p [S new {u 42 d {1 2} n 2}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [S fromnative $p] [S setnative $p u 99] [S fromnative $p]
    } -result {{u 42 n 2 d {1.0 2.0}} {} {u 99 n 2 d {1.0 2.0}}}

    test struct-setnative-varsize-1 "setnative varsize struct at index 0" -setup {
        cffi::Struct create S {u uchar n {int {default 2}} d double[n]}
        set p [S new {u 42 d {1 2} n 2}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [S fromnative $p] [S setnative $p u 99 0] [S fromnative $p]
    } -result {{u 42 n 2 d {1.0 2.0}} {} {u 99 n 2 d {1.0 2.0}}}

    test struct-setnative-varsize-2 "setnative varsize struct at index 1" -setup {
        cffi::Struct create S {u uchar n {int {default 2}} d double[n]}
        set p [S new {u 42 d {1 2} n 2}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [S fromnative $p] [S setnative $p u 99 1] [S fromnative $p]
    } -result {Operation indexing failed on ::cffi::test::S. Operation not permitted on variable sized structs.} -returnCodes error

    test struct-setnative-varsize-3 "setnative varsize struct at index 1" -setup {
        cffi::Struct create S {n {int {default 2}} d double[n]}
        set p [S new {d {1 2} n 2}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [catch {S setnative $p d {3 4} 1} message] $message [S fromnative $p]
    } -result {1 {Operation indexing failed on ::cffi::test::S. Operation not permitted on variable sized structs.} {n 2 d {1.0 2.0}}}

    test struct-setnative-varsize-4 "setnative varsize struct - count must not be modified" -setup {
        cffi::Struct create S {n {int {default 2}} d double[n]}
        set p [S new {d {1 2} n 2}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [catch {S setnative $p n 3} message] $message [S fromnative $p]
    } -result {1 {Invalid value "n". The count field in a variable size struct must not be modified.} {n 2 d {1.0 2.0}}}

    test struct-setnative-varsize-5 "setnative varsize struct vla must not be modified." -setup {
        cffi::Struct create S {n {int {default 2}} d double[n]}
        set p [S new {d {1 2} n 2}]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p d {3 4}
    } -result {Operation setnative failed on ::cffi::test::S. Operation not permitted on variable sized structs.} -returnCodes error

    test struct-setnative-varsize-6 "setnative varsize struct nested varsize must not be modified." -setup {
        cffi::Struct create S {n {int {default 2}} d double[n]}
        cffi::Struct create T {u uchar s struct.S}
        set p [T new {u 42 s {d {1 2} n 2}}]
    } -cleanup {
        T free $p
        T destroy
        S destroy
    } -body {
        list \
            [catch {T setnative $p s {n 2 d {3 4}}} message] \
            $message \
            [T fromnative $p] \
            [T setnative $p u 99] \
            [T fromnative $p]
    } -result {1 {Operation setnative failed on ::cffi::test::T. Operation not permitted on variable sized structs.} {u 42 s {n 2 d {1.0 2.0}}} {} {u 99 s {n 2 d {1.0 2.0}}}}

    ###
    # struct setnative!

    testnumargs struct-setnative! "::TestStruct setnative!" "POINTER FIELD VALUE" "?INDEX?"
    test struct-setnative!-0 "setnative! each field struct" -setup {
        set p [::TestStruct allocate]
        cffi::pointer dispose $p
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct ts
    } -cleanup {
        cffi::pointer safe $p
        ::TestStruct free $p
    } -body {
        dict for {key val} $ts {
            ::TestStruct setnative! $p $key $val
        }
        checkTestStruct [::TestStruct fromnative! $p]
    } -result ""

    test struct-setnative!-error-1 "setnative! NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative! NULL i 42
    } -result {Invalid value. Pointer is NULL.} -returnCodes error

    ###
    # struct getnativefields
    testnumargs struct-getnativefields "::TestStruct getnativefields" "POINTER FIELDNAMES" "?INDEX?"
    test struct-getnativefields-0 "Empty fieldlist" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        S tonative $p [list c 1 i {2 3} d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {}
    } -result {}
    test struct-getnativefields-1 "full fieldlist" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        S tonative $p [list c 1 i {2 3} d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {c i d}
    } -result {1 {2 3} 4.0}
    test struct-getnativefields-2 "fields out of order" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        S tonative $p [list c 1 i {2 3} d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {d c}
    } -result {4.0 1}
    test struct-getnativefields-3 "indexed" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate 2]
        S tonative $p [list c 1 i {2 3} d 4]
        S tonative $p [list c 10 i {20 30} d 40] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {d c i} 1
    } -result {40.0 10 {20 30}}
    test struct-getnativefields-error-0 "null pointer" -setup {
        ::cffi::Struct create S {c schar d double }
    } -cleanup {
        S destroy
    } -body {
        S getnativefields NULL {d c}
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test struct-getnativefields-error-1 "wrong type pointer" -setup {
        ::cffi::Struct create S {c schar d double }
    } -cleanup {
        S destroy
    } -body {
        S getnativefields [makeptr 1 ::TestStruct] {d c}
    } -result "Value \"[makeptr 1 ::TestStruct]\" has the wrong type. Expected pointer to ::cffi::test::S." -returnCodes error
    test struct-getnativefields-error-2 "unknown field" -setup {
        ::cffi::Struct create S {c schar d double }
        set p [S allocate]
        S tonative $p [list c 1 d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p nosuchfield
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    test struct-getnativefields-error-3 "unsafe pointer" -body {
        ::TestStruct getnativefields 1^::TestStruct {}
    } -result "Invalid value \"1^::TestStruct\". Pointer validation failed: not registered." -returnCodes error

    test struct-getnativefields-varsize-0 "struct getnativefields - varsize" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 2 d { 2 3}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnativefields $p {n d}
    } -result {2 {2.0 3.0}}

    test struct-getnativefields-varsize-1 "struct getnativefields - nested varsize" -setup {
        cffi::Struct create ::S {n int d double[n]}
        cffi::Struct create ::T {i int s struct.S}
        set p [::T new {i 42 s {n 2 d { 2 3}}}]
    } -cleanup {
        ::T free $p
        rename ::T ""
        rename ::S ""
    } -body {
        ::T getnativefields $p {s i}
    } -result {{n 2 d {2.0 3.0}} 42}

    test struct-getnativefields-varsize-2 "struct getnativefields - varsize index 0" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 2 d { 2 3}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnativefields $p {n d} 0
    } -result {2 {2.0 3.0}}

    test struct-getnativefields-varsize-2 "struct getnativefields - varsize index 1" -setup {
        cffi::Struct create ::S {n int d double[n]}
        set p [::S new {n 2 d { 2 3}}]
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        ::S getnativefields $p {n d} 1
    } -result {Operation indexing failed on ::S. Operation not permitted on variable sized structs.} -returnCodes error


    ###
    # struct getnativefields!
    testnumargs struct-getnativefields! "::TestStruct getnativefields!" "POINTER FIELDNAMES" "?INDEX?"
    test struct-getnativefields!-0 "getnativefields! full fieldlist" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        cffi::pointer dispose $p
        S tonative! $p [list c 1 i {2 3} d 4]
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        S destroy
    } -body {
        S getnativefields! $p {c i d}
    } -result {1 {2 3} 4.0}

    test struct-getnativefields!-error-0 "null pointer" -setup {
        ::cffi::Struct create S {c schar d double }
    } -cleanup {
        S destroy
    } -body {
        S getnativefields! NULL {d c}
    } -result {Invalid value. Pointer is NULL.} -returnCodes error

    ###
    # struct new
    testnumargs struct-new "::TestStruct new" "" "?INITIALIZER?"
    test struct-new-0 "struct new" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        ::S destroy
    } -body {
        set p [S new {c 1 i 2 s 3}]
        list [::cffi::pointer tag $p] [::cffi::pointer isvalid $p] [S fromnative $p] [S free $p]
    } -result [list ::S 1 {c 1 i 2 s 3} {}]

    test struct-new-1 "struct new different field order" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        set p [S new {i 2 s 3 c 1}]
        S fromnative $p
    } -result {c 1 i 2 s 3}

    test struct-new-2 "struct new with test struct" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct sval
    } -cleanup {
        ::TestStruct free $p
    } -body {
        set p [::TestStruct new $sval]
        checkTestStruct [::TestStruct fromnative $p]
    } -result ""

    test struct-new-3 "struct new with -clear" -setup {
        cffi::Struct create ::S {c uchar i longlong s short} -clear
    } -cleanup {
        ::S destroy
    } -body {
        set p [S new]
        list [::cffi::pointer tag $p] [::cffi::pointer isvalid $p] [S fromnative $p] [S free $p]
    } -result [list ::S 1 {c 0 i 0 s 0} {}]

    test struct-new-3 "struct new with default field values" -setup {
        cffi::Struct create ::S {i {int {default 42}} b {double {default 24}}}
    } -cleanup {
        ::S destroy
    } -body {
        set p [S new]
        list [::cffi::pointer tag $p] [::cffi::pointer isvalid $p] [S fromnative $p] [S free $p]
    } -result [list ::S 1 {i 42 b 24.0} {}]

    test struct-new-4 "struct with winchars multisz" -setup {
        cffi::Struct create S {w {winchars[10] multisz}}
    } -cleanup {
        S free $p
        S destroy
    } -constraints win -body {
        set p [S new [list w [list {a b} cd e]]]
        S fromnative $p
    } -result [list w [list {a b} cd e]]

    test struct-new-4.a "struct with winchars multisz - error" -setup {
        cffi::Struct create S {w {winchars[9] multisz}}
    } -cleanup {
        S destroy
    } -constraints win -body {
        S new [list w [list {a b} cd e]]
    } -result {Invalid value "{a b} cd e". String length is greater than specified maximum buffer size. Error converting field ::cffi::test::S.w to a native value.} -returnCodes error


    test struct-new-error-0 "struct new bad value" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S new {c a i 0 s 0}
    } -result {expected integer but got "a" Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-1 "struct new missing field" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S new {i 0 s 0}
    } -result {Struct field "c" not found or inaccessible. Field missing in struct dictionary value. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-2 "struct new chars overflow" -setup {
        cffi::Struct create ::S {c chars[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abc}
    } -result {Invalid value "abc". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-6 "struct new unichars overflow" -setup {
        cffi::Struct create ::S {c unichars[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abc}
    } -result {Invalid value "abc". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-6.winchars "struct new winchars overflow" -setup {
        cffi::Struct create ::S {c winchars[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abc}
    } -constraints win -result {Invalid value "abc". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-7 "struct new bytes overflow" -setup {
        cffi::Struct create ::S {c bytes[3]}
    } -cleanup {
        rename ::S ""
    } -body {
        S new {c abcd}
    } -result {Invalid value. Byte array length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-8 "struct new - struct with strings" -body {
        StructWithStrings new [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context. Error converting field ::StructWithStrings.s to a native value.} -returnCodes error

    test struct-new-varsize-0 "struct new - varsize" -setup {
        cffi::Struct create ::S {n int d double[n]}
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        set p [::S new {n 2 d { 2 3}}]
        ::S fromnative $p
    } -result {n 2 d {2.0 3.0}} -match dict

    test struct-new-varsize-1 "struct new - varsize - more values than space " -setup {
        cffi::Struct create ::S {n int d double[n]}
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        set p [::S new {n 2 d { 2 3 4}}]
        ::S fromnative $p
    } -result {n 2 d {2.0 3.0}} -match dict

    test struct-new-varsize-2 "struct new - varsize - fewer values than space " -setup {
        cffi::Struct create ::S {n int d double[n]}
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        set p [::S new {n 2 d { 1 }}]
        ::S fromnative $p
    } -result {n 2 d {1.0 0.0}} -match dict

    test struct-new-varsize-3 "struct new - varsize - clear" -setup {
        cffi::Struct create ::S {n int d double[n]} -clear
    } -cleanup {
        ::S free $p
        rename ::S ""
    } -body {
        set p [::S new {n 2}]
        ::S fromnative $p
    } -result {n 2 d {0.0 0.0}} -match dict

    test struct-new-varsize-4 "struct new - varsize - clear, no count specified" -setup {
        cffi::Struct create ::S {n int d double[n]} -clear
    } -cleanup {
        rename ::S ""
    } -body {
        set p [::S new {d {1 2}}]
    } -result {Invalid value "n". No value supplied for dynamic field count.} -returnCodes error

    ###
    # Bug fixes

    test struct-bug-53-0 "Check that command is actually a struct" -body {
        cffi::type info {struct.lindex}
    } -result {Struct "lindex" not found or inaccessible.} -returnCodes error
    test struct-bug-53-1 "Check that command is actually a struct" -body {
        cffi::type info {struct.nosuchstruct}
    } -result {Struct "nosuchstruct" not found or inaccessible.} -returnCodes error
    test struct-bug-53-2 "Check that command is actually a struct" -body {
        cffi::Struct create S {x int}
        proc S {} {}
        cffi::type info {struct.S}
    } -cleanup {
        rename S {}
    } -result {Struct "S" not found or inaccessible.} -returnCodes error

    #
    # Variable size struct tests

    test struct-varsize-error-0 {Variable size struct must have one more field} -body {
        cffi::Struct create S {a int[n]}
    } -result {Invalid value "int[n]". Field of variable size must be the last and must not be the only field.} -returnCodes error
    test struct-varsize-error-1 {Variable size struct must be last} -body {
        cffi::Struct create S {a int[n] n int}
    } -result {Invalid value "int[n]". Field of variable size must be the last and must not be the only field.} -returnCodes error
    test struct-varsize-error-2 {Variable size count field must be integer} -body {
        cffi::Struct create S {n double a int[n]}
    } -result {Field "n" not found or inaccessible. Could not find referenced count for dynamic array, possibly wrong type or not scalar.} -returnCodes error
    test struct-varsize-error-3 {Arrays of variable size structs not permitted} -setup {
        cffi::Struct create S {n int a int[n]}
    } -cleanup {
        S destroy
    } -body {
        cffi::type info {struct.S[2]}
    } -result {Invalid value "struct.S[2]". Array element types must be fixed size.} -returnCodes error

    test struct-varsize-nested-error-0 {Nested variable size struct must be last} -setup {
        cffi::Struct create S {n int a int[n]}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create Outer {s struct.S i int}
    } -result {Invalid value "struct.S". Field of variable size must be the last and must not be the only field.} -returnCodes error
    test struct-varsize-nested-error-2 {Nested variable size struct must not be an array} -setup {
        cffi::Struct create S {n int a int[n]}
        cffi::Struct create Outer {i int s struct.S}
    } -cleanup {
        Outer destroy
        S destroy
    } -body {
        cffi::type info {struct.Outer[2]}
    } -result {Invalid value "struct.Outer[2]". Array element types must be fixed size.} -returnCodes error

    #
    # Packed structs
    proc testpackederror {pack} {
        test struct-offsets-pack$pack "Struct -pack $pack" -cleanup {
            catch {S destroy}
        } -body {
            cffi::Struct create S {uc uchar dbl double s ushort} -pack $pack
            S info
        } -result "Invalid value \"$pack\". -pack option value must be 0, 1, 2, 4, 8 or 16." -returnCodes error
    }
    proc testpacked {pack result} {
        test struct-pack$pack-info "Struct info -pack $pack" -cleanup {
            S destroy
        } -body {
            cffi::Struct create S {uc uchar dbl double s ushort} -pack $pack
            S info
        } -result $result

        test struct-pack$pack "Struct get data -pack $pack" -setup {
            cffi::Struct create S {uc uchar dbl double s short} -pack $pack
        } -cleanup {
            S free $pStruct
            S destroy
        } -body {
            set pStruct [S new {uc 42 dbl 99 s -42}]
            S fromnative $pStruct
        } -result {uc 42 dbl 99.0 s -42}
    }
    testpackederror -1
    testpackederror 3
    testpackederror 32
    testpacked 0 {Size 24 Alignment 8 Flags 0 Fields {uc {Size 1 Offset 0 Definition uchar} dbl {Size 8 Offset 8 Definition double} s {Size 2 Offset 16 Definition ushort}}}
    testpacked 1 {Size 11 Alignment 1 Flags 0 Fields {uc {Size 1 Offset 0 Definition uchar} dbl {Size 8 Offset 1 Definition double} s {Size 2 Offset 9 Definition ushort}}}
    testpacked 2 {Size 12 Alignment 2 Flags 0 Fields {uc {Size 1 Offset 0 Definition uchar} dbl {Size 8 Offset 2 Definition double} s {Size 2 Offset 10 Definition ushort}}}
    testpacked 4 {Size 16 Alignment 4 Flags 0 Fields {uc {Size 1 Offset 0 Definition uchar} dbl {Size 8 Offset 4 Definition double} s {Size 2 Offset 12 Definition ushort}}}
    testpacked 8 {Size 24 Alignment 8 Flags 0 Fields {uc {Size 1 Offset 0 Definition uchar} dbl {Size 8 Offset 8 Definition double} s {Size 2 Offset 16 Definition ushort}}}
    testpacked 16 {Size 24 Alignment 8 Flags 0 Fields {uc {Size 1 Offset 0 Definition uchar} dbl {Size 8 Offset 8 Definition double} s {Size 2 Offset 16 Definition ushort}}}

    ###
    # Extras, might already be tested elsewhere
    test struct-pointer-field-0 "pointer fields are always unsafe" -setup {
        cffi::Struct create S {p pointer}
    } -body {
        dict get [S info] Fields p Definition
    } -result {pointer unsafe}
    test struct-pointer-field-1 "pointer fields are always unsafe" -setup {
        cffi::Struct create S {p {pointer counted}}
    } -body {
        dict get [S info] Fields p Definition
    } -result {pointer unsafe}
    test struct-pointer-field-1 "pointer fields are always unsafe" -setup {
        cffi::Struct create S {p {pointer pinned}}
    } -body {
        dict get [S info] Fields p Definition
    } -result {pointer unsafe}

    ###
    # Test base-derived casts
    test struct-casts-0 "struct cast to base" -setup {
        cffi::Struct create ::B {c uchar d double}
        cffi::Struct create ::D {c uchar d double s short}
        cffi::pointer castable ::D ::B
        set p [D new {c 1 d 99 s 2}]
    } -cleanup {
        cffi::pointer uncastable ::D
        ::D free $p
        rename B ""
        rename D ""
    } -body {
        list [cffi::pointer isvalid $p] [::B fromnative $p]
    } -result [list 1 {c 1 d 99.0}]
    test struct-casts-0 "struct cast to base" -setup {
        cffi::Struct create ::B {c uchar d double}
        cffi::Struct create ::D {c uchar d double s short}
        cffi::pointer castable ::D ::B
        set p [B new {c 1 d 99}]
    } -cleanup {
        cffi::pointer uncastable ::D
        ::B free $p
        rename B ""
        rename D ""
    } -body {
        ::D fromnative $p
    } -result {Value * has the wrong type. Expected pointer to ::D.} -returnCodes error -match glob

    ###
    # struct guids
    test struct-uuid-getnative-0 "struct uuid field" -setup {
        cffi::Struct create S {c uchar u uuid}
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set p [S new [list c 42 u $testValues(uuid)]]
        S getnative $p u
    } -result $testValues(uuid)

    test struct-uuid-describe-0 "struct uuid describe" -setup {
        cffi::Struct create S {c uchar u uuid}
    } -cleanup {
        S destroy
    } -body {
        S describe
    } -result "Struct ::cffi::test::S nRefs=1 size=[expr {[onwindows] ? 20 : 17}] alignment=[expr {[onwindows] ? 4 : 1}] flags=0 nFields=2\n  uchar c offset=0 size=1\n  uuid u offset=[expr {[onwindows] ? 4 : 1}] size=16"

    test struct-uuid-info-0 "struct uuid info" -setup {
        cffi::Struct create S {c uchar u uuid}
    } -cleanup {
        S destroy
    } -body {
        S info
    } -result [expr {[onwindows] ? "Size 20 Alignment 4 Flags 0 Fields {c {Size 1 Offset 0 Definition uchar} u {Size 16 Offset 4 Definition uuid}}" : "Size 17 Alignment 1 Flags 0 Fields {c {Size 1 Offset 0 Definition uchar} u {Size 16 Offset 1 Definition uuid}}"}]

    test struct-uuid-setnative-0 "struct uuid field" -setup {
        cffi::Struct create S {c uchar u {uuid {default 5d549ebb-f6e9-4995-af96-095f54fbf1dc}}}
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set p [S new [list c 42]]
        list [S getnative $p u] [S setnative $p u $testValues(uuid)] [S fromnative $p]
    } -result {5d549ebb-f6e9-4995-af96-095f54fbf1dc {} {c 42 u 01020304-0506-0708-090a-0b0c0d0e0f00}}
}

::tcltest::cleanupTests
namespace delete cffi::test
