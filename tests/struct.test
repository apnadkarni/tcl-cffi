# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# Contains common definitions across test scripts

source [file join [file dirname [info script]] common.tcl]

namespace eval cffi::test {
    testsubcmd ::cffi::Struct

    test struct-error-0 {Missing argument} -body {
        list [catch {Struct new} result] $result $::errorCode
    } -result {1 {wrong # args: should be "Struct new STRUCTDEF ?-clear?"} {TCL WRONGARGS}}

    test struct-error-1 {Empty struct definition} -body {
        list [catch {Struct new {}} result] $result $::errorCode
    } -result [list 1 {Invalid value "". Empty struct or missing type definition for field.} {cffi INVALID_VALUE {Invalid value "". Empty struct or missing type definition for field.}}]

    test struct-error-2 {Empty struct name} -body {
        list [catch {uplevel #0 {cffi::Struct create "" {i int}}} result] $result $::errorCode
    } -result {1 {Invalid value "". Empty string specified for structure name.} {cffi INVALID_VALUE {Invalid value "". Empty string specified for structure name.}}}

    test struct-error-3 {Duplicate field names} -body {
        list [catch {cffi::Struct new {i int i int}} result] $result $::errorCode
    } -result {1 {Field "i" already exists. Field names in a struct must be unique.} {cffi EXISTS {Field "i" already exists. Field names in a struct must be unique.}}}

    test struct-error-4 {Bad option argument} -body {
        list [catch {Struct new {s int} -foo} result] $result
    } -result {1 {bad option "-foo": must be -clear}}


    proc teststruct {type} {
        variable errorMessages

        # Skip scalar tests for these
        if {$type in {chars bytes}} {
            set Size 1
            set Alignment 1
        } elseif {$type eq "unichars"} {
            set Size 2
            set Alignment 2
        } else {
            set tinfo [cffi::type info $type]
            dict with tinfo {}
            test struct-$type-0 "struct new $type" -cleanup {
                $s destroy
            } -body {
                set s [cffi::Struct new "fld $type"]
                $s info
            } -result [list Size $Size Alignment $Alignment Flags 0 Fields [list fld [list Size $Size Offset 0 Definition $type]]] -match dict

            test struct-$type-1 "struct create {schar $type}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "c schar fld $type"
                S info
            } -result [list Size [expr {2*$Size}] Alignment $Alignment Flags 0 Fields [list c [list Size 1 Offset 0 Definition schar] fld [list Size $Size Offset $Size Definition $type]]] -match dict

            test struct-$type-2 "struct create {$type uchar}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "fld $type c uchar"
                S info
            } -result [list Size [expr {2*$Size}] Alignment $Alignment Flags 0 Fields [list fld [list Size $Size Offset 0 Definition $type] c [list Size 1 Offset $Size Definition uchar] ]] -match dict
        }
        test struct-$type-3 "struct create {schar $type\[2\]}" -cleanup {
            S destroy
        } -body {
            cffi::Struct create S "c schar fld $type\[2\] c2 schar"
            S info
        } -result [list \
                       Size [expr {4*$Size}] \
                       Alignment $Alignment \
                       Flags 0 Fields [list \
                                           c [list Size 1 Offset 0 Definition schar] \
                                           fld [list Size [expr {2*$Size}] Offset $Size Definition [list "$type\[2\]"]] \
                                           c2 [list Size 1 Offset [expr {3*$Size}] Definition schar]]]
    }

    # Struct size, offset and alignment tests
    foreach type $baseTypes {
        if {$type in {void binary}} {
            test struct-$type-error-0 "struct create $type" -body {
                cffi::Struct create S "fld $type"
            } -returnCodes error -result "Invalid value \"$type\". $errorMessages(typeparsemode)"
        } else {
            teststruct $type
        }
    }

    test struct-offsets-0 "struct offsets" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set sinfo [::TestStruct info]
        set mismatches [list ]
        if {[getTestStruct s] != [dict get $sinfo Size]} {
            lappend mismatches size
        }
        lappend mismatches {*}[checkTestStruct $s]
    } -result [list]

    test struct-namespace-0 "Verify global struct available in namespace" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.S}
    } -result 4

    test struct-namespace-1 "Verify global struct available in namespace with :: prefix" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.::S}
    } -result 4

    test struct-namespace-2 "Verify struct available in namespace" -cleanup {
        namespace delete ::tempns
    } -body {
        list [namespace eval ::tempns {
            ::cffi::Struct create S {x int}
            cffi::type size struct.S
        }] [::tempns::S name]
    } -result [list 4 ::tempns::S]


    test struct-namespace-3 "Verify qualified struct available in namespace" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.tempnsA::S}
    } -result 4

    test struct-namespace-4 "Verify qualified struct available in namespace with ::" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.::tempnsA::S}
    } -result 4

    test struct-namespace-error-0 "Verify unqualified struct fails" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.S}
    } -result "Struct definition \"S\" not found or inaccessible. " -returnCodes error

    ###
    # struct allocate
    testnumargs struct-allocate "::TestStruct allocate" "" "?COUNT?"

    test struct-allocate-0 "struct allocate" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-1 "struct allocate array" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate 10]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-2 "struct allocate check tag" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        S free $p
        rename S {}
    } -body {
        set p [S allocate]
        cffi::pointer tag $p
    } -result [namespace current]::S

    test struct-allocate-error-0 "struct allocate zero count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate 0
    } -result {Invalid value. Array size must be a positive integer.} -returnCodes error

    test struct-allocate-error-2 "struct allocate negative count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -1
    } -result {Invalid value. Array size must be a positive integer.} -returnCodes error

    ###
    # struct free
    testnumargs struct-free "::TestStruct free" "POINTER" ""
    test struct-free-0 "struct free" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [S free $p] \
            [catch {S free $p} result] \
            [string match "Pointer $p is not registered." $result]
    } -result [list {} 1 1]

    test struct-free-1 "struct free NULL pointer" -setup {
        cffi::Struct create ::S {x int}
    } -cleanup {
        rename ::S {}
    } -body {
        ::S free 0^::S
    } -result ""

    ###
    # struct fromnative
    testnumargs struct-fromnative "::TestStruct fromnative" "POINTER" "?INDEX?"

    test struct-fromnative-0 "struct fromnative" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.::TestStruct}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative-1 "struct fromnative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.::S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    test struct-fromnative-error-0 "struct fromnative - unsafe pointer" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.TestStruct}
    } -cleanup {
        cffi::pointer safe $p
        TestStruct free $p
    } -body {
        cffi::pointer dispose $p
        set s [::TestStruct fromnative $p]
    } -result {^Pointer 0x[[:xdigit:]]+\^::TestStruct is not registered\.$} -match regexp -returnCodes error

    ###
    # fromnative!
    testnumargs struct-fromnative! "::TestStruct fromnative!" "POINTER" "?INDEX?"

    test struct-fromnative!-0 "struct fromnative!" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p {pointer.::TestStruct unsafe}}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative! $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative!-1 "struct fromnative! index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.::S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative! $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    test struct-fromnative!-2 "struct fromnative! - unsafe" -setup {
        set p [TestStruct allocate]
        cffi::pointer dispose $p ;# Make unsafe
        testDll function getTestStruct int {p {pointer.::TestStruct unsafe}}
    } -cleanup {
        cffi::pointer safe $p ;# Before freeing
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative! $p]
        checkTestStruct $s
    } -result [list]


    ###
    # struct tonative
    testnumargs struct-tonative "::TestStruct tonative" "POINTER INITIALIZER" "?INDEX?"
    test struct-tonative-0 "struct tonative" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3}] [S fromnative $p]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-1 "struct tonative scalar" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3} 0] [S fromnative $p 0]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-2 "struct tonative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate 3]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c 4 i 5 s 6} 1
        S tonative $p {c 1 i 2 s 3} 0
        S tonative $p {c 7 i 8 s 9} 2
        list [S fromnative $p 0] [S fromnative $p 1] [S fromnative $p 2]
    } -result {{c 1 i 2 s 3} {c 4 i 5 s 6} {c 7 i 8 s 9}}

    test struct-tonative-3 "struct tonative different field order" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {i 2 s 3 c 1}
        S fromnative $p 0
    } -result {c 1 i 2 s 3}
    
    test struct-tonative-error-0 "struct tonative bad value" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c a i 0 s 0}
    } -result {expected integer but got "a"} -returnCodes error

    test struct-tonative-error-1 "struct tonative missing field" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {i 0 s 0}
    } -result {Struct field "c" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error

    test struct-tonative-error-2 "struct tonative chars overflow" -setup {
        cffi::Struct create ::S {c chars[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value "abcd". String length is greater than specified maximum buffer size.} -returnCodes error

    test struct-tonative-error-6 "struct tonative unichars overflow" -setup {
        cffi::Struct create ::S {c unichars[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value "abcd". String length is greater than specified maximum buffer size.} -returnCodes error

    test struct-tonative-error-7 "struct tonative bytes overflow" -setup {
        cffi::Struct create ::S {c bytes[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value. Byte array length is greater than specified maximum buffer size.} -returnCodes error

    test struct-tonative-error-8 "struct tonative - struct with strings" -body {
        set p [StructWithStrings allocate]
        StructWithStrings tonative $p [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context.} -returnCodes error


    ###
    # struct describe
    # Hardcoded - fix TBD
    testnumargs struct-describe "::TestStruct describe"
    test struct-describe-0 "struct describe" -constraints disabled -body {
        regsub -all {\s+} [TestStruct describe] " "
    } -result [regsub -all {\s+} {Struct TestStruct nRefs=1 size=128 alignment=8 nFields=16
        schar c offset=0 size=1
        int i offset=4 size=4
        short shrt offset=8 size=2
        uint ui offset=12 size=4
        ushort ushrt offset=16 size=2
        long l offset=20 size=4
        uchar uc offset=24 size=1
        ulong ul offset=28 size=4
        chars c3[13] offset=32 size=13
        longlong ll offset=48 size=8
        unichars unic[13] offset=56 size=26
        ulonglong ull offset=88 size=8
        bytes b[3] offset=96 size=3
        float f offset=100 size=4
        struct cffi::test::InnerTestStruct s offset=104 size=15
        double d offset=120 size=8} " "]

    ###
    # tobinary/frombinary
    testnumargs struct-tobinary "::TestStruct tobinary" "DICTIONARY"
    testnumargs struct-frombinary "::TestStruct frombinary" "BINARY"

    test struct-tobinary-0 "struct tobinary" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct s
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set b [TestStruct tobinary $s]
        list [string length $b] [checkTestStruct [TestStruct frombinary $b]]
    } -result [list $testStructSize {}]

    test struct-tobinary-1 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        if {$::tcl_platform(pointerSize) == 4} {
            set scanner n
        } else {
            set scanner m
        }
        binary scan $bin ${scanner}3 result
        set result
    } -result {1 2 3}

    test struct-tobinary-2 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        S frombinary $bin
    } -result [list ptrs [make_unsafe_pointers 1 2 3]]

    test struct-tobinary-error-0 "struct tobinary missing field" -setup {
        cffi::Struct create ::S {x int y int}
    } -body {
        S tobinary {x 0}
    } -result {Struct field "y" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error

    test struct-tobinary-error-1 "struct tobinary - struct with strings" -body {
        StructWithStrings tobinary [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context.} -returnCodes error

    test struct-frombinary-error-0 "struct frombinary truncated" -setup {
        catch {::S destroy}
        cffi::Struct create ::S {x int y int}
        set b [S tobinary {x 0 y 1}]
    } -cleanup {
        rename S ""
    } -body {
        S frombinary [string range $b 0 end-1]
    } -result {Invalid value. Truncated structure binary value.} -returnCodes error

    ###
    # struct name

    test struct-name-0 "struct name in namespace" -setup {
        cffi::Struct create S {x int y int}
    } -body {
        # Name should not have leading ::
        S name
    } -result "::cffi::test::S"

    ###
    # Aliases in structs

    test struct-alias-0 "struct field alias" -setup {
        cffi::alias define Pointer {pointer unsafe}
        cffi::Struct create S {x int p Pointer}
    } -body {
        S info
    } -result "Size [expr {2*$::tcl_platform(pointerSize)}] Alignment $::tcl_platform(pointerSize) Flags 0 Fields {x {Size 4 Offset 0 Definition int} p {Size $::tcl_platform(pointerSize) Offset $::tcl_platform(pointerSize) Definition {pointer unsafe}}}"

    test struct-alias-1 "struct field array alias" -setup {
        cffi::alias define Array {int[4]}
        cffi::Struct create S {x schar a Array}
    } -body {
        S info
    } -result {Size 20 Alignment 4 Flags 0 Fields {x {Size 1 Offset 0 Definition schar} a {Size 16 Offset 4 Definition {{int[4]}}}}}


    ###
    # pointer handling in fields
    test struct-pointer-nullok-0 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer nullok unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]

    test struct-pointer-nullok-1 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result {Invalid value. Pointer is NULL.} -returnCodes error

    test struct-pointer-nullok-2 "NULL pointer in output field" -body {
        cffi::Struct create S {p {pointer nullok unsafe}}
        cffi::Struct create S2 {p {pointer unsafe}}
        S2 frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]


    ###
    # struct field defaults
    # Note: struct tobinary does not support string/unistring. Those will have
    # to be covered in function.test
    foreach {type val} {
        schar -1 uchar 1 short -2 ushort 2 int -3 uint 3 long -4 ulong 4
        longlong -5 ulonglong 5 float 0.5 double 1.5
        chars[3] ab unichars[3] de
    } {
        test struct-field-default-$type-0 "$type field with default" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld $val]

        test struct-field-default-$type-0 "$type field with default -arg supplied" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {fld 42}]
        } -cleanup {
            $s destroy
        } -result [list fld [expr {$type in $realTypes ? 42.0 : 42}]]
    }

    ###
    # Struct field structsize annotation
    foreach {type val} {
        schar uchar short ushort int uint long ulong longlong ulonglong
    } {
        test struct-field-structsize-$type-0 "$type field structsize" -body {
            set s [cffi::Struct new [list fld [list $type structsize]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld [dict get [cffi::type info $type] Size]]
    }
    foreach type {float double pointer chars[2] unichars[2] string unistring binary struct.::TestStruct} {
        test struct-field-structsize-$type-error-0 "$type field structsize" -body {
            cffi::Struct new [list fld [list $type structsize]]
        } -result "Invalid value \"[list $type] structsize\". $errorMessages(attrtype)" -returnCodes error
    }

    ###
    # -clear option
    test struct-clear-0 "struct create -clear" -body {
        cffi::Struct create S {i int j int k {int {default 2}}} -clear
        S frombinary [S tobinary {j 1}]
    } -cleanup {
        S destroy
    } -result {i 0 j 1 k 2}

    test struct-clear-1 "struct new -clear" -body {
        set s [cffi::Struct new {i int j {int {default 1}} k int} -clear]
        $s frombinary [$s tobinary {}]
    } -cleanup {
        $s destroy
    } -result {i 0 j 1 k 0}

    ###
    # enum and bitmask
    test struct-enum-0 "struct field enum" -setup {
        cffi::enum define E {A 1 B 42}
    } -body {
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i B}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i B}
    test struct-enum-1 "struct field enum with bitmask" -setup {
        cffi::enum define E {A 1 B 2}
    } -body {
        cffi::Struct create S {i {int {enum E} bitmask}}
        S frombinary [S tobinary {i {A B 4}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i {A B 4}}
    test struct-enum-2 "struct field enum array with bitmask" -setup {
        cffi::enum define E {A 1 B 2 C 4}
    } -body {
        cffi::Struct create S {i {int[3] {enum E} bitmask}}
        S frombinary [S tobinary {i {A {B C} {A 8}}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i {{A 0} {B C 0} {A 8}}}
    test struct-enum-error-0 "struct field num with unknown enum" -body {
        cffi::Struct create S {i {int {enum NOSUCHENUM}}}
    } -result {Enum "NOSUCHENUM" not found or inaccessible. } -returnCodes error
    test struct-enum-error-1 "struct field num with unknown enum value" -body {
        cffi::enum define E {A 1 B 2 C 4}
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i X}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {expected integer but got "X"} -returnCodes error

    ###
    # Scope tests
    test struct-enum-scope-0 "struct field enum - local scope" -setup {
        cffi::enum delete *
        namespace eval :: {
            cffi::enum delete *
            cffi::enum define E {A 0}
        }
        namespace eval ::ns {
            cffi::enum delete *
            cffi::enum define E {A 1}
        }
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i {int {enum E}}}]
        S frombinary [S tobinary {i A}]
    } -cleanup {
        S destroy
    } -result {i A}
    test struct-enum-scope-1 "struct field enum - local fall back to global" -setup {
        cffi::enum delete *
        namespace eval :: {
            cffi::enum delete *
            cffi::enum define E {A 0}
        }
        namespace eval ::ns {cffi::enum delete *}
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i {int {enum E}}}]
        S frombinary [S tobinary {i A}]
    } -cleanup {
        S destroy
    } -result {i A}

    test struct-alias-scope-0 "struct field alias - local scope" -setup {
        cffi::alias delete *
        namespace eval :: {
            cffi::alias delete *
            cffi::alias define INT uchar
        }
        namespace eval ::ns {
            cffi::alias delete *
            cffi::alias define INT int
        }
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i INT}]
        # Would error out if global INT was used
        S frombinary [S tobinary {i 256}]
    } -cleanup {
        S destroy
    } -result {i 256}

    ###
    # fieldpointer
    testnumargs struct-fieldpointer "::TestStruct fieldpointer" "POINTER FIELD" "?TAG? ?INDEX?"

    test struct-fieldpointer-0 "Address of first field in struct" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr c
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [makeptr 8]

    test struct-fieldpointer-1 "Address of non-first field in struct, tag" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr i TAG]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 12 TAG] 0]

    test struct-fieldpointer-2 "Address of field in struct, tag, index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr i TAG 2]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 28 TAG] 0]
    test struct-fieldpointer-3 "Address of field in struct, no tag, index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr c "" 1]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 16] 0]

    test struct-fieldpointer-error-0 "Address of invalid field name" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr nosuchfield
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    test struct-fieldpointer-error-1 "Address of field - invalid index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr i TAG -1
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result {Value -1 not in range. Must be within [0,2147483647].} -returnCodes error
    test struct-fieldpointer-error-2 "Address of field - wrong pointer type" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S2]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr i
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result "Value \"[scoped_ptr 8 S2]\" has the wrong type. Pointer type mismatch." -returnCodes error

    test struct-fieldpointer-error-3 "Address of field - unsafe pointer" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
    } -body {
        S fieldpointer $ptr i
    } -cleanup {
        S destroy
    } -result "Pointer [scoped_ptr 8 S] is not registered." -returnCodes error

    ###
    # struct get
    testnumargs struct-get "::TestStruct get" "POINTER FIELD" "?INDEX?"
    test struct-get-0 "Get each field struct" -setup {
        testDll function getTestStruct int {p pointer.::TestStruct}
        set p [::TestStruct allocate]
        getTestStruct $p
        unset -nocomplain testval
    } -cleanup {
        ::TestStruct free $p
    } -body {
        dict for {name -} [dict get [::TestStruct info] Fields] {
            lappend testval $name [::TestStruct get $p $name]
        }
        checkTestStruct $testval
    } -result ""
    test struct-get-1 "get pointer field with tag" -setup {
        ::cffi::Struct create S {c schar i int p pointer.S}
        set p [S allocate]
        S tonative $p [list c 1 i 2 p $p]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [S get $p c] [S get $p i] [string equal $p [S get $p p]]
    } -result {1 2 1}
    test struct-get-2 "get at index" -setup {
        ::cffi::Struct create S {c schar d double}
        set p [S allocate 2]
        S tonative $p [list c 1 d 2]
        S tonative $p [list c 10 d 20] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list \
            [S get $p c] [S get $p d] \
            [S get $p c 1] [S get $p d 1]
    } -result {1 2.0 10 20.0}
    test struct-get-3 "get pointer safety - safe" -setup {
        ::cffi::Struct create S {p pointer}
        set p [S allocate]
        # Note no need to initialize allocation
    } -cleanup {
        cffi::pointer dispose $ptrval
        S free $p
        S destroy
    } -body {
        set ptrval [S get $p p]
        cffi::pointer isvalid $ptrval
    } -result 1
    test struct-get-4 "get pointer safety - unsafe" -setup {
        ::cffi::Struct create S {p {pointer unsafe}}
        set p [S allocate]
        # Note no need to initialize allocation
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set ptrval [S get $p p]
        cffi::pointer isvalid $ptrval
    } -result 0
    test struct-get-error-0 "Unsafe pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S get [scoped_ptr 1 S] i
    } -result "Pointer [scoped_ptr 1 S] is not registered." -returnCodes error
    test struct-get-error-1 "Wrong tag pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S get [scoped_ptr 1 S2] i
    } -result "Value \"[scoped_ptr 1 S2]\" has the wrong type. Pointer type mismatch." -returnCodes error
    test struct-get-error-2 "NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S get NULL i
    } -result "Pointer [scoped_ptr 0 S] is not registered." -returnCodes error
    test struct-get-error-3 "get invalid field name" -setup {
        ::cffi::Struct create S {c schar}
        set p [S allocate]
        S tonative $p [list c 1]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S get $p nosuchfield
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    ###
    # struct set

    testnumargs struct-set "::TestStruct set" "POINTER FIELD VALUE" "?INDEX?"
    test struct-set-0 "Set each field struct" -setup {
        set p [::TestStruct allocate]
        unset -nocomplain testval
    } -cleanup {
        ::TestStruct free $p
    } -body {
        foreach {fld val} {
            c 0 i 4 shrt 8 ui 12 ushrt 16 l 20 uc 24 ul 28 c3 32 ll 48 unic 56 ull 88 b `ab f 100.0 s {c 104} d 120.0
        } {
            ::TestStruct set $p $fld $val
        }
        checkTestStruct [::TestStruct fromnative $p]
    } -result ""
    test struct-set-1 "set pointer field with tag" -setup {
        ::cffi::Struct create S {c schar p pointer.S}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S set $p c 42
        S set $p p $p
        list [S get $p c] [string equal $p [S get $p p]]
    } -result {42 1}
    test struct-set-2 "set at index" -setup {
        ::cffi::Struct create S {c schar d double}
        set p [S allocate 2]
        S tonative $p [list c 1 d 2]
        S tonative $p [list c 10 d 20] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S set $p c 100 1
        S set $p d 200 1
        list [S fromnative $p] [S fromnative $p 1]
    } -result {{c 1 d 2.0} {c 100 d 200.0}}
    test struct-set-3 "set pointer safety - unsafe" -setup {
        ::cffi::Struct create S {p {pointer unsafe}}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S set $p p [makeptr 1]
        set ptrval [S get $p p]
        list $ptrval [cffi::pointer isvalid $ptrval]
    } -result [list [makeptr 1] 0]
    test struct-set-error-0 "Unsafe pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S set [scoped_ptr 1 S] i 42
    } -result "Pointer [scoped_ptr 1 S] is not registered." -returnCodes error
    test struct-set-error-1 "Wrong tag pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S set [scoped_ptr 1 S2] i 42
    } -result "Value \"[scoped_ptr 1 S2]\" has the wrong type. Pointer type mismatch." -returnCodes error
    test struct-set-error-2 "NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S set NULL i 42
    } -result "Pointer [scoped_ptr 0 S] is not registered." -returnCodes error
    test struct-set-error-3 "set invalid field name" -setup {
        ::cffi::Struct create S {c schar}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S set $p nosuchfield 1
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error
    set testnum -1
    foreach {fld val} {
        c 256 i notanint shrt 100000 ui -1 ushrt -1 l notanint uc -1 ul -1 c3 morethan13chars ll notanint unic morethan13chars ull -1 b morethan3bytes f notanumber s {unknownfield 104} d notanumber
    } {
        test struct-set-value-error-[incr testnum] "Set field struct bad $fld value" -setup {
            set p [::TestStruct allocate]
            testDll function getTestStruct int {p pointer.::TestStruct}
            getTestStruct $p
        } -cleanup {
            ::TestStruct free $p
        } -body {
            list [catch {::TestStruct set $p $fld $val} result] \
                [regexp {not in range|expected.*but got|greater than.*maximum buffer|Field missing} $result] [checkTestStruct [::TestStruct fromnative $p]]
        } -result {1 1 {}}
    }

    ###
    # Bug fixes

    test struct-bug-53-0 "Check that command is actually a struct" -body {
        cffi::type info {struct.lindex}
    } -result {Invalid value "lindex". Not a cffi::Struct.} -returnCodes error
    test struct-bug-53-1 "Check that command is actually a struct" -body {
        cffi::type info {struct.nosuchstruct}
    } -result {Struct definition "nosuchstruct" not found or inaccessible. } -returnCodes error
    test struct-bug-53-2 "Check that command is actually a struct" -body {
        cffi::Struct create S {x int}
        proc S {} {}
        cffi::type info {struct.S}
    } -cleanup {
        rename S {}
    } -result {Invalid value "S". Not a cffi::Struct.} -returnCodes error
}

::tcltest::cleanupTests
namespace delete cffi::test
