# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# Contains common definitions across test scripts

source [file join [file dirname [info script]] common.tcl]

namespace eval cffi::test {
    testsubcmd ::cffi::Struct

    test struct-error-0 {Missing argument} -body {
        list [catch {Struct new} result] $result $::errorCode
    } -result {1 {wrong # args: should be "Struct new STRUCTDEF ?-clear?"} {TCL WRONGARGS}}

    test struct-error-1 {Empty struct definition} -body {
        list [catch {Struct new {}} result] $result $::errorCode
    } -result [list 1 {Invalid value "". Empty struct or missing type definition for field.} {cffi INVALID_VALUE {Invalid value "". Empty struct or missing type definition for field.}}]

    test struct-error-2 {Empty struct name} -body {
        list [catch {uplevel #0 {cffi::Struct create "" {i int}}} result] $result $::errorCode
    } -result {1 {Invalid value "". Empty string specified for structure name.} {cffi INVALID_VALUE {Invalid value "". Empty string specified for structure name.}}}

    test struct-error-3 {Duplicate field names} -body {
        list [catch {cffi::Struct new {i int i int}} result] $result $::errorCode
    } -result {1 {Field "i" already exists. Field names in a struct must be unique.} {cffi EXISTS {Field "i" already exists. Field names in a struct must be unique.}}}

    test struct-error-4 {Bad option argument} -body {
        list [catch {Struct new {s int} -foo} result] $result
    } -result {1 {bad option "-foo": must be -clear}}


    proc teststruct {type} {
        variable errorMessages

        # Skip scalar tests for these
        if {$type in {chars bytes}} {
            set size 1
            set alignment 1
        } elseif {$type eq "unichars"} {
            set size 2
            set alignment 2
        } else {
            set tinfo [cffi::type info $type]
            dict with tinfo {}
            test struct-$type-0 "struct new $type" -cleanup {
                $s destroy
            } -body {
                set s [cffi::Struct new "fld $type"]
                $s info
            } -result [list size $size alignment $alignment flags 0 fields [list fld [list size $size offset 0 definition $type]]] -match dict

            test struct-$type-1 "struct create {schar $type}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "c schar fld $type"
                S info
            } -result [list size [expr {2*$size}] alignment $alignment flags 0 fields [list c [list size 1 offset 0 definition schar] fld [list size $size offset $size definition $type]]] -match dict

            test struct-$type-2 "struct create {$type uchar}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "fld $type c uchar"
                S info
            } -result [list size [expr {2*$size}] alignment $alignment flags 0 fields [list fld [list size $size offset 0 definition $type] c [list size 1 offset $size definition uchar] ]] -match dict
        }
        if {$type ni {string unistring}} {
            test struct-$type-3 "struct create {schar $type\[2\]}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "c schar fld $type\[2\] c2 schar"
                S info
            } -result [list \
                           size [expr {4*$size}] \
                           alignment $alignment \
                           flags 0 fields [list \
                                       c [list size 1 offset 0 definition schar] \
                                       fld [list size [expr {2*$size}] offset $size definition [list "$type\[2\]"]] \
                                       c2 [list size 1 offset [expr {3*$size}] definition schar]]]
        } else {
            test struct-$type-3 "struct create {schar $type\[2\]}" -body {
                cffi::Struct create S "c schar fld $type\[2\] c2 schar"
            } -result "Invalid value \"$type\[2\]\". $errorMessages(unsupportedarraytype)" -returnCodes error
        }
    }

    # Struct size, offset and alignment tests
    foreach type $baseTypes {
        if {$type in {void binary}} {
            test struct-$type-error-0 "struct create $type" -body {
                cffi::Struct create S "fld $type"
            } -returnCodes error -result "Invalid value \"$type\". $errorMessages(typeparsemode)"
        } else {
            teststruct $type
        }
    }

    test struct-offsets-0 "struct offsets" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set sinfo [::TestStruct info]
        set mismatches [list ]
        if {[getTestStruct s] != [dict get $sinfo size]} {
            lappend mismatches size
        }
        lappend mismatches {*}[checkTestStruct $s]
    } -result [list]

    test struct-namespace-0 "Verify global struct available in namespace" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.S}
    } -result 4

    test struct-namespace-1 "Verify global struct available in namespace with :: prefix" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.::S}
    } -result 4

    test struct-namespace-2 "Verify struct available in namespace" -cleanup {
        namespace delete ::tempns
    } -body {
        list [namespace eval ::tempns {
            ::cffi::Struct create S {x int}
            cffi::type size struct.S
        }] [::tempns::S name]
    } -result [list 4 tempns::S]


    test struct-namespace-3 "Verify qualified struct available in namespace" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.tempnsA::S}
    } -result 4

    test struct-namespace-4 "Verify qualified struct available in namespace with ::" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.::tempnsA::S}
    } -result 4

    test struct-namespace-error-0 "Verify unqualified struct fails" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.S}
    } -result "Struct definition \"S\" not found or inaccessible. " -returnCodes error

    ###
    # struct allocate
    testnumargs struct-allocate "::TestStruct allocate" "" "?COUNT?"

    test struct-allocate-0 "struct allocate" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-1 "struct allocate array" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate 10]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-2 "struct allocate check tag" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        S free $p
        rename S {}
    } -body {
        set p [S allocate]
        cffi::pointer tag $p
    } -result [string trimleft [namespace current] :]::S

    test struct-allocate-error-0 "struct allocate zero count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate 0
    } -result {Invalid value. Array size must be a positive integer.} -returnCodes error

    test struct-allocate-error-2 "struct allocate negative count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -1
    } -result {Invalid value. Array size must be a positive integer.} -returnCodes error

    ###
    # struct free
    testnumargs struct-free "::TestStruct free" "POINTER" ""
    test struct-free-0 "struct free" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [S free $p] \
            [catch {S free $p} result] \
            [string match "Pointer $p is not registered." $result]
    } -result [list {} 1 1]

    test struct-free-1 "struct free NULL pointer" -setup {
        cffi::Struct create ::S {x int}
    } -cleanup {
        rename ::S {}
    } -body {
        ::S free 0^S
    } -result ""

    ###
    # struct fromnative
    testnumargs struct-fromnative "::TestStruct fromnative" "POINTER" "?INDEX?"

    test struct-fromnative-0 "struct fromnative" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.TestStruct}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative-1 "struct fromnative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    ###
    # struct tonative
    testnumargs struct-tonative "::TestStruct tonative" "POINTER INITIALIZER" "?INDEX?"
    test struct-tonative-0 "struct tonative" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3}] [S fromnative $p]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-1 "struct tonative scalar" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3} 0] [S fromnative $p 0]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-2 "struct tonative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate 3]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c 4 i 5 s 6} 1
        S tonative $p {c 1 i 2 s 3} 0
        S tonative $p {c 7 i 8 s 9} 2
        list [S fromnative $p 0] [S fromnative $p 1] [S fromnative $p 2]
    } -result {{c 1 i 2 s 3} {c 4 i 5 s 6} {c 7 i 8 s 9}}

    test struct-tonative-3 "struct tonative different field order" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {i 2 s 3 c 1}
        S fromnative $p 0
    } -result {c 1 i 2 s 3}
    
    test struct-tonative-error-0 "struct tonative bad value" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c a i 0 s 0}
    } -result {expected integer but got "a"} -returnCodes error

    test struct-tonative-error-1 "struct tonative missing field" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {i 0 s 0}
    } -result {Struct field "c" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error

    test struct-tonative-error-2 "struct tonative chars overflow" -setup {
        cffi::Struct create ::S {c chars[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value "abcd". String length is greater than specified maximum buffer size.} -returnCodes error

    test struct-tonative-error-6 "struct tonative unichars overflow" -setup {
        cffi::Struct create ::S {c unichars[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value "abcd". String length is greater than specified maximum buffer size.} -returnCodes error

    test struct-tonative-error-7 "struct tonative bytes overflow" -setup {
        cffi::Struct create ::S {c bytes[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value. Byte array length is greater than specified maximum buffer size.} -returnCodes error

    test struct-tonative-error-8 "struct tonative - struct with strings" -body {
        set p [StructWithStrings allocate]
        StructWithStrings tonative $p [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context.} -returnCodes error


    ###
    # struct describe
    # Hardcoded - fix TBD
    testnumargs struct-describe "::TestStruct describe"
    test struct-describe-0 "struct describe" -constraints disabled -body {
        regsub -all {\s+} [TestStruct describe] " "
    } -result [regsub -all {\s+} {Struct TestStruct nRefs=1 size=128 alignment=8 nFields=16
        schar c offset=0 size=1
        int i offset=4 size=4
        short shrt offset=8 size=2
        uint ui offset=12 size=4
        ushort ushrt offset=16 size=2
        long l offset=20 size=4
        uchar uc offset=24 size=1
        ulong ul offset=28 size=4
        chars c3[13] offset=32 size=13
        longlong ll offset=48 size=8
        unichars unic[13] offset=56 size=26
        ulonglong ull offset=88 size=8
        bytes b[3] offset=96 size=3
        float f offset=100 size=4
        struct cffi::test::InnerTestStruct s offset=104 size=15
        double d offset=120 size=8} " "]

    ###
    # tobinary/frombinary
    testnumargs struct-tobinary "::TestStruct tobinary" "DICTIONARY"
    testnumargs struct-frombinary "::TestStruct frombinary" "BINARY"

    test struct-tobinary-0 "struct tobinary" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct s
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set b [TestStruct tobinary $s]
        list [string length $b] [checkTestStruct [TestStruct frombinary $b]]
    } -result [list $testStructSize {}]

    test struct-tobinary-1 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        if {$::tcl_platform(pointerSize) == 4} {
            set scanner n
        } else {
            set scanner m
        }
        binary scan $bin ${scanner}3 result
        set result
    } -result {1 2 3}

    test struct-tobinary-2 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        S frombinary $bin
    } -result [list ptrs [make_unsafe_pointers 1 2 3]]

    test struct-tobinary-error-0 "struct tobinary missing field" -setup {
        cffi::Struct create ::S {x int y int}
    } -body {
        S tobinary {x 0}
    } -result {Struct field "y" not found or inaccessible. Field missing in struct dictionary value.} -returnCodes error

    test struct-tobinary-error-1 "struct tobinary - struct with strings" -body {
        StructWithStrings tobinary [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context.} -returnCodes error

    test struct-frombinary-error-0 "struct frombinary truncated" -setup {
        catch {::S destroy}
        cffi::Struct create ::S {x int y int}
        set b [S tobinary {x 0 y 1}]
    } -cleanup {
        rename S ""
    } -body {
        S frombinary [string range $b 0 end-1]
    } -result {Invalid value. Truncated structure binary value.} -returnCodes error

    ###
    # struct name

    test struct-name-0 "struct name in namespace" -setup {
        cffi::Struct create S {x int y int}
    } -body {
        # Name should not have leading ::
        S name
    } -result "cffi::test::S"

    ###
    # Aliases in structs

    test struct-alias-0 "struct field alias" -setup {
        cffi::alias define Pointer {pointer unsafe}
        cffi::Struct create S {x int p Pointer}
    } -body {
        S info
    } -result "size [expr {2*$::tcl_platform(pointerSize)}] alignment $::tcl_platform(pointerSize) flags 0 fields {x {size 4 offset 0 definition int} p {size $::tcl_platform(pointerSize) offset $::tcl_platform(pointerSize) definition {pointer unsafe}}}"

    test struct-alias-1 "struct field array alias" -setup {
        cffi::alias define Array {int[4]}
        cffi::Struct create S {x schar a Array}
    } -body {
        S info
    } -result {size 20 alignment 4 flags 0 fields {x {size 1 offset 0 definition schar} a {size 16 offset 4 definition {{int[4]}}}}}


    ###
    # pointer handling in fields
    test struct-pointer-nullok-0 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer nullok unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]

    test struct-pointer-nullok-1 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result {Invalid value. Pointer is NULL.} -returnCodes error

    test struct-pointer-nullok-2 "NULL pointer in output field" -body {
        cffi::Struct create S {p {pointer nullok unsafe}}
        cffi::Struct create S2 {p {pointer unsafe}}
        S2 frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]


    ###
    # struct field defaults
    # Note: struct tobinary does not support string/unistring. Those will have
    # to be covered in function.test
    foreach {type val} {
        schar -1 uchar 1 short -2 ushort 2 int -3 uint 3 long -4 ulong 4
        longlong -5 ulonglong 5 float 0.5 double 1.5
        chars[3] ab unichars[3] de
    } {
        test struct-field-default-$type-0 "$type field with default" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld $val]

        test struct-field-default-$type-0 "$type field with default -arg supplied" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {fld 42}]
        } -cleanup {
            $s destroy
        } -result [list fld [expr {$type in $realTypes ? 42.0 : 42}]]
    }

    ###
    # Struct field structsize annotation
    foreach {type val} {
        schar uchar short ushort int uint long ulong longlong ulonglong
    } {
        test struct-field-structsize-$type-0 "$type field structsize" -body {
            set s [cffi::Struct new [list fld [list $type structsize]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld [dict get [cffi::type info $type] size]]
    }
    foreach type {float double pointer chars[2] unichars[2] string unistring binary struct.::TestStruct} {
        test struct-field-structsize-$type-error-0 "$type field structsize" -body {
            cffi::Struct new [list fld [list $type structsize]]
        } -result "Invalid value \"[list $type] structsize\". $errorMessages(attrtype)" -returnCodes error
    }

    ###
    # -clear option
    test struct-clear-0 "struct create -clear" -body {
        cffi::Struct create S {i int j int k {int {default 2}}} -clear
        S frombinary [S tobinary {j 1}]
    } -cleanup {
        S destroy
    } -result {i 0 j 1 k 2}

    test struct-clear-1 "struct new -clear" -body {
        set s [cffi::Struct new {i int j {int {default 1}} k int} -clear]
        $s frombinary [$s tobinary {}]
    } -cleanup {
        $s destroy
    } -result {i 0 j 1 k 0}

    ###
    # enum and bitmask
    test struct-enum-0 "struct field enum" -setup {
        cffi::enum define E {A 1 B 42}
    } -body {
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i B}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i 42}
    test struct-enum-1 "struct field enum with bitmask" -setup {
        cffi::enum define E {A 1 B 2}
    } -body {
        cffi::Struct create S {i {int {enum E} bitmask}}
        S frombinary [S tobinary {i {A B 4}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i 7}
    test struct-enum-2 "struct field enum array with bitmask" -setup {
        cffi::enum define E {A 1 B 2 C 4}
    } -body {
        cffi::Struct create S {i {int[3] {enum E} bitmask}}
        S frombinary [S tobinary {i {A {B C} {A 8}}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i {1 6 9}}
    test struct-enum-error-0 "struct field num with unknown enum" -body {
        cffi::Struct create S {i {int {enum NOSUCHENUM}}}
    } -result {Enum "NOSUCHENUM" not found or inaccessible. } -returnCodes error
    test struct-enum-error-1 "struct field num with unknown enum value" -body {
        cffi::enum define E {A 1 B 2 C 4}
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i X}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {Enum member name "X" not found or inaccessible. } -returnCodes error

    ###
    # Bug fixes

    test struct-bug-53-0 "Check that command is actually a struct" -body {
        cffi::type info {struct.lindex}
    } -result {Invalid value "lindex". Not a cffi::Struct.} -returnCodes error
    test struct-bug-53-1 "Check that command is actually a struct" -body {
        cffi::type info {struct.nosuchstruct}
    } -result {Struct definition "nosuchstruct" not found or inaccessible. } -returnCodes error
    test struct-bug-53-2 "Check that command is actually a struct" -body {
        cffi::Struct create S {x int}
        proc S {} {}
        cffi::type info {struct.S}
    } -cleanup {
        rename S {}
    } -result {Invalid value "S". Not a cffi::Struct.} -returnCodes error
}

::tcltest::cleanupTests
namespace delete cffi::test
