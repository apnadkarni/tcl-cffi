# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# Contains common definitions across test scripts

source [file join [file dirname [info script]] common.tcl]

namespace eval cffi::test {
    testsubcmd ::cffi::Struct

    test struct-error-0 {Missing argument} -body {
        list [catch {Struct new} result] $result $::errorCode
    } -result {1 {wrong # args: should be "Struct new STRUCTDEF ?-clear?"} {TCL WRONGARGS}}

    test struct-error-1 {Empty struct definition} -body {
        list [catch {Struct new {}} result] $result $::errorCode
    } -result [list 1 {Invalid value "". Empty struct or missing type definition for field.} {cffi INVALID_VALUE {Invalid value "". Empty struct or missing type definition for field.}}]

    test struct-error-2 {Empty struct name} -body {
        list [catch {uplevel #0 {cffi::Struct create "" {i int}}} result] $result $::errorCode
    } -result {1 {Invalid value "". Empty string specified for structure name.} {cffi INVALID_VALUE {Invalid value "". Empty string specified for structure name.}}}

    test struct-error-3 {Duplicate field names} -body {
        list [catch {cffi::Struct new {i int i int}} result] $result $::errorCode
    } -result {1 {Field "i" already exists. Field names in a struct must be unique.} {cffi EXISTS {Field "i" already exists. Field names in a struct must be unique.}}}

    test struct-error-4 {Bad option argument} -body {
        list [catch {Struct new {s int} -foo} result] $result
    } -result {1 {bad option "-foo": must be -clear}}


    proc teststruct {type} {
        variable errorMessages
        variable unicharSize

        # Skip scalar tests for these
        if {$type in {chars bytes}} {
            set Size 1
            set Alignment 1
        } elseif {$type eq "unichars"} {
            set Size $unicharSize
            set Alignment $unicharSize
        } elseif {$type eq "winchars"} {
            set Size 2
            set Alignment 2
        } else {
            set tinfo [cffi::type info $type]
            dict with tinfo {}
            test struct-$type-0 "struct new $type" -cleanup {
                $s destroy
            } -body {
                set s [cffi::Struct new "fld $type"]
                $s info
            } -result [list Size $Size Alignment $Alignment Flags 0 Fields [list fld [list Size $Size Offset 0 Definition $type]]] -match dict

            test struct-$type-1 "struct create {schar $type}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "c schar fld $type"
                S info
            } -result [list Size [expr {2*$Size}] Alignment $Alignment Flags 0 Fields [list c [list Size 1 Offset 0 Definition schar] fld [list Size $Size Offset $Size Definition $type]]] -match dict

            test struct-$type-2 "struct create {$type uchar}" -cleanup {
                S destroy
            } -body {
                cffi::Struct create S "fld $type c uchar"
                S info
            } -result [list Size [expr {2*$Size}] Alignment $Alignment Flags 0 Fields [list fld [list Size $Size Offset 0 Definition $type] c [list Size 1 Offset $Size Definition uchar] ]] -match dict
        }
        test struct-$type-3 "struct create {schar $type\[2\]}" -cleanup {
            S destroy
        } -body {
            cffi::Struct create S "c schar fld $type\[2\] c2 schar"
            S info
        } -result [list \
                       Size [expr {4*$Size}] \
                       Alignment $Alignment \
                       Flags 0 Fields [list \
                                           c [list Size 1 Offset 0 Definition schar] \
                                           fld [list Size [expr {2*$Size}] Offset $Size Definition [list "$type\[2\]"]] \
                                           c2 [list Size 1 Offset [expr {3*$Size}] Definition schar]]]
    }

    # Struct size, offset and alignment tests
    foreach type $baseTypes {
        if {$type in {void binary}} {
            test struct-$type-error-0 "struct create $type" -body {
                cffi::Struct create S "fld $type"
            } -returnCodes error -result "Invalid value \"$type\". $errorMessages(typeparsemode)"
        } else {
            teststruct $type
        }
    }

    test struct-offsets-0 "struct offsets" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set sinfo [::TestStruct info]
        set mismatches [list ]
        if {[getTestStruct s] != [dict get $sinfo Size]} {
            lappend mismatches size
        }
        lappend mismatches {*}[checkTestStruct $s]
    } -result [list]

    test struct-namespace-0 "Verify global struct available in namespace" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.S}
    } -result 4

    test struct-namespace-1 "Verify global struct available in namespace with :: prefix" -cleanup {
        rename ::S ""
        namespace delete ::tempns
    } -body {
        ::cffi::Struct create ::S {x int}
        namespace eval ::tempns {cffi::type size struct.::S}
    } -result 4

    test struct-namespace-2 "Verify struct available in namespace" -cleanup {
        namespace delete ::tempns
    } -body {
        list [namespace eval ::tempns {
            ::cffi::Struct create S {x int}
            cffi::type size struct.S
        }] [::tempns::S name]
    } -result [list 4 ::tempns::S]


    test struct-namespace-3 "Verify qualified struct available in namespace" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.tempnsA::S}
    } -result 4

    test struct-namespace-4 "Verify qualified struct available in namespace with ::" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.::tempnsA::S}
    } -result 4

    test struct-namespace-error-0 "Verify unqualified struct fails" -cleanup {
        namespace delete ::tempnsA
        namespace delete ::tempnsB
    } -body {
        namespace eval ::tempnsA {::cffi::Struct create S {x int}}
        namespace eval ::tempnsB {cffi::type size struct.S}
    } -result "Struct definition \"S\" not found or inaccessible. " -returnCodes error

    ###
    # struct allocate
    testnumargs struct-allocate "::TestStruct allocate" "" "?COUNT ?VLACOUNT??"

    test struct-allocate-0 "struct allocate" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-1 "struct allocate array" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate 10]
        list [cffi::pointer isvalid $p] [S free $p] [cffi::pointer isvalid $p]
    } -result {1 {} 0}

    test struct-allocate-2 "struct allocate check tag" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        S free $p
        rename S {}
    } -body {
        set p [S allocate]
        cffi::pointer tag $p
    } -result [namespace current]::S

    test struct-allocate-error-0 "struct allocate zero count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate 0
    } -result {Invalid value. Array size must be a positive integer.} -returnCodes error

    test struct-allocate-error-2 "struct allocate negative count" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        S allocate -1
    } -result {Invalid value. Array size must be a positive integer.} -returnCodes error

    ###
    # struct free
    testnumargs struct-free "::TestStruct free" "POINTER" ""
    test struct-free-0 "struct free" -setup {
        cffi::Struct create S {x int}
    } -cleanup {
        rename S {}
    } -body {
        set p [S allocate]
        list [S free $p] \
            [catch {S free $p} result] \
            [string match "Pointer $p is not registered." $result]
    } -result [list {} 1 1]

    test struct-free-1 "struct free NULL pointer" -setup {
        cffi::Struct create ::S {x int}
    } -cleanup {
        rename ::S {}
    } -body {
        ::S free 0^::S
    } -result ""

    ###
    # struct fromnative
    testnumargs struct-fromnative "::TestStruct fromnative" "POINTER" "?INDEX?"

    test struct-fromnative-0 "struct fromnative" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.::TestStruct}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative-1 "struct fromnative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.::S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    test struct-fromnative-error-0 "struct fromnative - unsafe pointer" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p pointer.TestStruct}
    } -cleanup {
        cffi::pointer safe $p
        TestStruct free $p
    } -body {
        cffi::pointer dispose $p
        set s [::TestStruct fromnative $p]
    } -result {^Pointer 0x[[:xdigit:]]+\^::TestStruct is not registered\.$} -match regexp -returnCodes error

    test struct-fromnative-error-1 "struct fromnative - null pointer" -body {
        ::TestStruct fromnative NULL
    } -result "*Pointer is NULL*" -match glob -returnCodes error

    ###
    # fromnative!
    testnumargs struct-fromnative! "::TestStruct fromnative!" "POINTER" "?INDEX?"

    test struct-fromnative!-0 "struct fromnative!" -setup {
        set p [TestStruct allocate]
        testDll function getTestStruct int {p {pointer.::TestStruct unsafe}}
    } -cleanup {
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative! $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative!-1 "struct fromnative! index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [S allocate 3]
        testDll function structArrayFill int {n int p pointer.::S}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [structArrayFill 3 $p] [S fromnative! $p 1]
    } -result [list 9 {c 4 i 5 s 6}]

    test struct-fromnative!-2 "struct fromnative! - unsafe" -setup {
        set p [TestStruct allocate]
        cffi::pointer dispose $p ;# Make unsafe
        testDll function getTestStruct int {p {pointer.::TestStruct unsafe}}
    } -cleanup {
        cffi::pointer safe $p ;# Before freeing
        TestStruct free $p
        rename getTestStruct ""
    } -body {
        getTestStruct $p
        set s [::TestStruct fromnative! $p]
        checkTestStruct $s
    } -result [list]

    test struct-fromnative!-error-0 "struct fromnative! - null pointer" -body {
        ::TestStruct fromnative! NULL
    } -result "*Pointer is NULL*" -match glob -returnCodes error


    ###
    # struct tonative
    testnumargs struct-tonative "::TestStruct tonative" "POINTER INITIALIZER" "?INDEX?"
    test struct-tonative-0 "struct tonative" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3}] [S fromnative $p]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-1 "struct tonative scalar" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [S tonative $p {c 1 i 2 s 3} 0] [S fromnative $p 0]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative-2 "struct tonative index" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate 3]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c 4 i 5 s 6} 1
        S tonative $p {c 1 i 2 s 3} 0
        S tonative $p {c 7 i 8 s 9} 2
        list [S fromnative $p 0] [S fromnative $p 1] [S fromnative $p 2]
    } -result {{c 1 i 2 s 3} {c 4 i 5 s 6} {c 7 i 8 s 9}}

    test struct-tonative-3 "struct tonative different field order" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {i 2 s 3 c 1}
        S fromnative $p 0
    } -result {c 1 i 2 s 3}
    
    test struct-tonative-error-0 "struct tonative bad value" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S new {c 0 i 1 s 2}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {c 10 i x s 11}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {expected integer but got "x" Error converting field ::S.i to a native value.} {c 0 i 1 s 2}]

    test struct-tonative-error-1 "struct tonative missing field" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S new {c 0 i 1 s 2}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {c 10 i 11}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {Struct field "s" not found or inaccessible. Field missing in struct dictionary value. Error converting field ::S.s to a native value.} {c 0 i 1 s 2}]

    test struct-tonative-error-2 "struct tonative chars overflow" -setup {
        cffi::Struct create ::S {i int c chars[3]}
        set p [::S new {i 0 c ab}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {i 42 c abcd}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {Invalid value "abcd". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} {i 0 c ab}]

    test struct-tonative-error-6 "struct tonative unichars overflow" -setup {
        cffi::Struct create ::S {i int c unichars[3]}
        set p [::S new {i 0 c ab}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {i 42 c abcd}} emsg] $emsg [S fromnative $p]
    } -result [list 1 {Invalid value "abcd". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} {i 0 c ab}]

    test struct-tonative-error-6.winchars "struct tonative winchars overflow" -setup {
        cffi::Struct create ::S {i int c winchars[3]}
        set p [::S new {i 0 c ab}]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        list [catch {S tonative $p {i 42 c abcd}} emsg] $emsg [S fromnative $p]
    } -constraints win -result [list 1 {Invalid value "abcd". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} {i 0 c ab}]


    test struct-tonative-error-7 "struct tonative bytes overflow" -setup {
        cffi::Struct create ::S {c bytes[3]}
        set p [::S allocate]
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        S tonative $p {c abcd}
    } -result {Invalid value. Byte array length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-tonative-error-8 "struct tonative - struct with strings" -body {
        set p [StructWithStrings allocate]
        StructWithStrings tonative $p [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context. Error converting field ::StructWithStrings.s to a native value.} -returnCodes error

    test struct-tonative-error-9 "struct tonative - unsafe pointer" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
        cffi::pointer dispose $p
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        rename S ""
    } -body {
        S tonative $p {c 1 i 2 s 3}
    } -result {^Pointer 0x[[:xdigit:]]+\^::S is not registered\.$} -match regexp -returnCodes error

    test struct-tonative-error-10 "struct tonative - NULL pointer" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S tonative NULL {c 1 i 2 s 3}
    } -result {*Pointer is NULL*} -match glob -returnCodes error

    ###
    # struct tonative!
    testnumargs struct-tonative! "::TestStruct tonative!" "POINTER INITIALIZER" "?INDEX?"
    test struct-tonative!-0 "struct tonative" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
        set p [::S allocate]
        cffi::pointer dispose $p
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        rename S ""
    } -body {
        list [S tonative! $p {c 1 i 2 s 3}] [S fromnative! $p]
    } -result [list {} {c 1 i 2 s 3}]

    test struct-tonative!-error-0 "struct tonative! - NULL pointer" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S tonative! NULL {c 1 i 2 s 3}
    } -result {*Pointer is NULL*} -match glob -returnCodes error

    ###
    # struct describe
    # Hardcoded - fix TBD
    testnumargs struct-describe "::TestStruct describe"
    test struct-describe-0 "struct describe" -constraints disabled -body {
        regsub -all {\s+} [TestStruct describe] " "
    } -result [regsub -all {\s+} {Struct TestStruct nRefs=1 size=128 alignment=8 nFields=16
        schar c offset=0 size=1
        int i offset=4 size=4
        short shrt offset=8 size=2
        uint ui offset=12 size=4
        ushort ushrt offset=16 size=2
        long l offset=20 size=4
        uchar uc offset=24 size=1
        ulong ul offset=28 size=4
        chars c3[13] offset=32 size=13
        longlong ll offset=48 size=8
        unichars unic[13] offset=56 size=26
        ulonglong ull offset=88 size=8
        bytes b[3] offset=96 size=3
        float f offset=100 size=4
        struct cffi::test::InnerTestStruct s offset=104 size=15
        double d offset=120 size=8} " "]

    ###
    # tobinary/frombinary
    testnumargs struct-tobinary "::TestStruct tobinary" "DICTIONARY"
    testnumargs struct-frombinary "::TestStruct frombinary" "BINARY"

    test struct-tobinary-0 "struct tobinary" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct s
    } -cleanup {
        rename getTestStruct ""
    } -body {
        set b [TestStruct tobinary $s]
        list [string length $b] [checkTestStruct [TestStruct frombinary $b]]
    } -result [list $testStructSize {}]

    test struct-tobinary-1 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        if {$::tcl_platform(pointerSize) == 4} {
            set scanner n
        } else {
            set scanner m
        }
        binary scan $bin ${scanner}3 result
        set result
    } -result {1 2 3}

    test struct-tobinary-2 "struct with pointer array" -setup {
        catch {S destroy}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {ptrs {pointer[3] unsafe}}
        set bin [S tobinary [list ptrs [make_unsafe_pointers 1 2 3]]]
        S frombinary $bin
    } -result [list ptrs [make_unsafe_pointers 1 2 3]]

    test struct-tobinary-error-0 "struct tobinary missing field" -setup {
        cffi::Struct create ::S {x int y int}
    } -body {
        S tobinary {x 0}
    } -result {Struct field "y" not found or inaccessible. Field missing in struct dictionary value. Error converting field ::S.y to a native value.} -returnCodes error

    test struct-tobinary-error-1 "struct tobinary - struct with strings" -body {
        StructWithStrings tobinary [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context. Error converting field ::StructWithStrings.s to a native value.} -returnCodes error

    test struct-frombinary-error-0 "struct frombinary truncated" -setup {
        catch {::S destroy}
        cffi::Struct create ::S {x int y int}
        set b [S tobinary {x 0 y 1}]
    } -cleanup {
        rename S ""
    } -body {
        S frombinary [string range $b 0 end-1]
    } -result {Invalid value. Truncated structure binary value.} -returnCodes error

    ###
    # struct name

    test struct-name-0 "struct name in namespace" -setup {
        cffi::Struct create S {x int y int}
    } -body {
        # Name should not have leading ::
        S name
    } -result "::cffi::test::S"

    ###
    # Aliases in structs

    test struct-alias-0 "struct field alias" -setup {
        cffi::alias define Pointer {pointer unsafe}
        cffi::Struct create S {x int p Pointer}
    } -body {
        S info
    } -result "Size [expr {2*$::tcl_platform(pointerSize)}] Alignment $::tcl_platform(pointerSize) Flags 0 Fields {x {Size 4 Offset 0 Definition int} p {Size $::tcl_platform(pointerSize) Offset $::tcl_platform(pointerSize) Definition {pointer unsafe}}}"

    test struct-alias-1 "struct field array alias" -setup {
        cffi::alias define Array {int[4]}
        cffi::Struct create S {x schar a Array}
    } -body {
        S info
    } -result {Size 20 Alignment 4 Flags 0 Fields {x {Size 1 Offset 0 Definition schar} a {Size 16 Offset 4 Definition {{int[4]}}}}}


    ###
    # pointer handling in fields
    test struct-pointer-nullok-0 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer nullok unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]

    test struct-pointer-nullok-1 "NULL pointer in field" -body {
        cffi::Struct create S {p {pointer unsafe}}
        S frombinary [S tobinary [list p [makeptr 0]]]
    } -result {Invalid value. Pointer is NULL. Error converting field ::cffi::test::S.p to a native value.} -returnCodes error

    test struct-pointer-nullok-2 "NULL pointer in output field" -body {
        cffi::Struct create S {p {pointer nullok unsafe}}
        cffi::Struct create S2 {p {pointer unsafe}}
        S2 frombinary [S tobinary [list p [makeptr 0]]]
    } -result [list p [makeptr 0]]


    ###
    # struct field defaults
    # Note: struct tobinary does not support string/unistring/winstring. Those will have
    # to be covered in function.test
    set matrix {
        schar -1 uchar 1 short -2 ushort 2 int -3 uint 3 long -4 ulong 4
        longlong -5 ulonglong 5 float 0.5 double 1.5
        chars[3] ab unichars[3] de
    }
    if {$::tcl_platform(platform) eq "windows"} {
        lappend matrix {winchars[3]} fg
    }

    foreach {type val} $matrix {
        test struct-field-default-$type-0 "$type field with default" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld $val]

        test struct-field-default-$type-0 "$type field with default -arg supplied" -body {
            set s [cffi::Struct new [list fld [list $type [list default $val]]]]
            $s frombinary [$s tobinary {fld 42}]
        } -cleanup {
            $s destroy
        } -result [list fld [expr {$type in $realTypes ? 42.0 : 42}]]
    }

    ###
    # Struct field structsize annotation
    foreach {type val} {
        schar uchar short ushort int uint long ulong longlong ulonglong
    } {
        test struct-field-structsize-$type-0 "$type field structsize" -body {
            set s [cffi::Struct new [list fld [list $type structsize]]]
            $s frombinary [$s tobinary {}]
        } -cleanup {
            $s destroy
        } -result [list fld [dict get [cffi::type info $type] Size]]
    }
    set matrix {float double pointer chars[2] unichars[2] string unistring binary struct.::TestStruct}
    if {$::tcl_platform(platform) eq "windows"} {
        lappend matrix winstring {winchars[2]}
    }
    foreach type $matrix {
        test struct-field-structsize-$type-error-0 "$type field structsize" -body {
            cffi::Struct new [list fld [list $type structsize]]
        } -result "Invalid value \"[list $type] structsize\". $errorMessages(attrtype)" -returnCodes error
    }

    ###
    # -clear option
    test struct-clear-0 "struct create -clear" -body {
        cffi::Struct create S {i int j int k {int {default 2}}} -clear
        S frombinary [S tobinary {j 1}]
    } -cleanup {
        S destroy
    } -result {i 0 j 1 k 2}

    test struct-clear-1 "struct new -clear" -body {
        set s [cffi::Struct new {i int j {int {default 1}} k int} -clear]
        $s frombinary [$s tobinary {}]
    } -cleanup {
        $s destroy
    } -result {i 0 j 1 k 0}

    ###
    # enum and bitmask
    test struct-enum-0 "struct field enum" -setup {
        cffi::enum define E {A 1 B 42}
    } -body {
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i B}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i B}
    test struct-enum-1 "struct field enum with bitmask" -setup {
        cffi::enum define E {A 1 B 2}
    } -body {
        cffi::Struct create S {i {int {enum E} bitmask}}
        S frombinary [S tobinary {i {A B 4}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i {A B 7}}
    test struct-enum-2 "struct field enum array with bitmask" -setup {
        cffi::enum define E {A 1 B 2 C 4}
    } -body {
        cffi::Struct create S {i {int[3] {enum E} bitmask}}
        S frombinary [S tobinary {i {A {B C} {A 8}}}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {i {{A 1} {B C 6} {A 9}}}
    test struct-enum-error-0 "struct field num with unknown enum" -body {
        cffi::Struct create S {i {int {enum NOSUCHENUM}}}
    } -result {Enum "NOSUCHENUM" not found or inaccessible. } -returnCodes error
    test struct-enum-error-1 "struct field num with unknown enum value" -body {
        cffi::enum define E {A 1 B 2 C 4}
        cffi::Struct create S {i {int {enum E}}}
        S frombinary [S tobinary {i X}]
    } -cleanup {
        cffi::enum delete E
        S destroy
    } -result {expected integer but got "X" Error converting field ::cffi::test::S.i to a native value.} -returnCodes error

    ###
    # Scope tests
    test struct-enum-scope-0 "struct field enum - local scope" -setup {
        cffi::enum delete *
        namespace eval :: {
            cffi::enum delete *
            cffi::enum define E {A 0}
        }
        namespace eval ::ns {
            cffi::enum delete *
            cffi::enum define E {A 1}
        }
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i {int {enum E}}}]
        S frombinary [S tobinary {i A}]
    } -cleanup {
        S destroy
    } -result {i A}
    test struct-enum-scope-1 "struct field enum - local fall back to global" -setup {
        cffi::enum delete *
        namespace eval :: {
            cffi::enum delete *
            cffi::enum define E {A 0}
        }
        namespace eval ::ns {cffi::enum delete *}
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i {int {enum E}}}]
        S frombinary [S tobinary {i A}]
    } -cleanup {
        S destroy
    } -result {i A}

    test struct-alias-scope-0 "struct field alias - local scope" -setup {
        cffi::alias delete *
        namespace eval :: {
            cffi::alias delete *
            cffi::alias define INT uchar
        }
        namespace eval ::ns {
            cffi::alias delete *
            cffi::alias define INT int
        }
    } -body {
        namespace eval ::ns [list cffi::Struct create [namespace current]::S {i INT}]
        # Would error out if global INT was used
        S frombinary [S tobinary {i 256}]
    } -cleanup {
        S destroy
    } -result {i 256}

    ###
    # fieldpointer
    testnumargs struct-fieldpointer "::TestStruct fieldpointer" "POINTER FIELD" "?TAG? ?INDEX?"

    test struct-fieldpointer-0 "Address of first field in struct" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr c
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [makeptr 8]

    test struct-fieldpointer-1 "Address of non-first field in struct, tag" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr i TAG]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 12 TAG] 0]

    test struct-fieldpointer-2 "Address of field in struct, tag, index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr i TAG 2]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 28 TAG] 0]
    test struct-fieldpointer-3 "Address of field in struct, no tag, index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        set fldptr [S fieldpointer $ptr c "" 1]
        list $fldptr [::cffi::pointer isvalid $fldptr]
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result [list [makeptr 16] 0]

    test struct-fieldpointer-error-0 "Address of invalid field name" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr nosuchfield
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    test struct-fieldpointer-error-1 "Address of field - invalid index" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr i TAG -1
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result {Value -1 not in range. Must be within [0,2147483647].} -returnCodes error
    test struct-fieldpointer-error-2 "Address of field - wrong pointer type" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S2]
        ::cffi::pointer safe $ptr
    } -body {
        S fieldpointer $ptr i
    } -cleanup {
        ::cffi::pointer dispose $ptr
        S destroy
    } -result "Value \"[scoped_ptr 8 S2]\" has the wrong type. Pointer type mismatch." -returnCodes error

    test struct-fieldpointer-error-3 "Address of field - unsafe pointer" -setup {
        ::cffi::Struct create S {c schar i int}
        set ptr [scoped_ptr 8 S]
    } -body {
        S fieldpointer $ptr i
    } -cleanup {
        S destroy
    } -result "Pointer [scoped_ptr 8 S] is not registered." -returnCodes error

    ###
    # struct getnative
    testnumargs struct-getnative "::TestStruct getnative" "POINTER FIELD" "?INDEX?"
    test struct-getnative-0 "Getnative each field struct" -setup {
        testDll function getTestStruct int {p pointer.::TestStruct}
        set p [::TestStruct allocate]
        getTestStruct $p
        unset -nocomplain testval
    } -cleanup {
        ::TestStruct free $p
    } -body {
        dict for {name -} [dict get [::TestStruct info] Fields] {
            lappend testval $name [::TestStruct getnative $p $name]
        }
        checkTestStruct $testval
    } -result ""
    test struct-getnative-1 "getnative pointer field with tag" -setup {
        ::cffi::Struct create S {c schar i int p pointer.S}
        set p [S allocate]
        S tonative $p [list c 1 i 2 p $p]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list [S getnative $p c] [S getnative $p i] [string equal $p [S getnative $p p]]
    } -result {1 2 1}
    test struct-getnative-2 "getnative at index" -setup {
        ::cffi::Struct create S {c schar d double}
        set p [S allocate 2]
        S tonative $p [list c 1 d 2]
        S tonative $p [list c 10 d 20] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        list \
            [S getnative $p c] [S getnative $p d] \
            [S getnative $p c 1] [S getnative $p d 1]
    } -result {1 2.0 10 20.0}
    test struct-getnative-3 "getnative pointer safety - safe" -setup {
        ::cffi::Struct create S {p pointer}
        set p [S allocate]
        # Note no need to initialize allocation
    } -cleanup {
        cffi::pointer dispose $ptrval
        S free $p
        S destroy
    } -body {
        set ptrval [S getnative $p p]
        cffi::pointer isvalid $ptrval
    } -result 1
    test struct-getnative-4 "getnative pointer safety - unsafe" -setup {
        ::cffi::Struct create S {p {pointer unsafe}}
        set p [S allocate]
        # Note no need to initialize allocation
    } -cleanup {
        S free $p
        S destroy
    } -body {
        set ptrval [S getnative $p p]
        cffi::pointer isvalid $ptrval
    } -result 0
    test struct-getnative-error-0 "Unsafe pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S getnative [scoped_ptr 1 S] i
    } -result "Pointer [scoped_ptr 1 S] is not registered." -returnCodes error
    test struct-getnative-error-1 "Wrong tag pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S getnative [scoped_ptr 1 S2] i
    } -result "Value \"[scoped_ptr 1 S2]\" has the wrong type. Pointer type mismatch." -returnCodes error
    test struct-getnative-error-2 "NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S getnative NULL i
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test struct-getnative-error-3 "getnative invalid field name" -setup {
        ::cffi::Struct create S {c schar}
        set p [S allocate]
        S tonative $p [list c 1]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnative $p nosuchfield
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error

    ###
    # struct setnative

    testnumargs struct-setnative "::TestStruct setnative" "POINTER FIELD VALUE" "?INDEX?"
    test struct-setnative-0 "Setnative each field struct" -setup {
        set p [::TestStruct allocate]
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct ts
    } -cleanup {
        ::TestStruct free $p
    } -body {
        dict for {key val} $ts {
            ::TestStruct setnative $p $key $val
        }
        checkTestStruct [::TestStruct fromnative $p]
    } -result ""
    test struct-setnative-1 "setnative pointer field with tag" -setup {
        ::cffi::Struct create S {c schar p pointer.S}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p c 42
        S setnative $p p $p
        list [S getnative $p c] [string equal $p [S getnative $p p]]
    } -result {42 1}
    test struct-setnative-2 "setnative at index" -setup {
        ::cffi::Struct create S {c schar d double}
        set p [S allocate 2]
        S tonative $p [list c 1 d 2]
        S tonative $p [list c 10 d 20] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p c 100 1
        S setnative $p d 200 1
        list [S fromnative $p] [S fromnative $p 1]
    } -result {{c 1 d 2.0} {c 100 d 200.0}}
    test struct-setnative-3 "setnative pointer safety - unsafe" -setup {
        ::cffi::Struct create S {p {pointer unsafe}}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p p [makeptr 1]
        set ptrval [S getnative $p p]
        list $ptrval [cffi::pointer isvalid $ptrval]
    } -result [list [makeptr 1] 0]
    test struct-setnative-error-0 "Unsafe pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative [scoped_ptr 1 S] i 42
    } -result "Pointer [scoped_ptr 1 S] is not registered." -returnCodes error
    test struct-setnative-error-1 "Wrong tag pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative [scoped_ptr 1 S2] i 42
    } -result "Value \"[scoped_ptr 1 S2]\" has the wrong type. Pointer type mismatch." -returnCodes error
    test struct-setnative-error-2 "NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative NULL i 42
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test struct-setnative-error-3 "setnative invalid field name" -setup {
        ::cffi::Struct create S {c schar}
        set p [S allocate]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S setnative $p nosuchfield 1
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error
    set testnum -1
    set testvals {
        c 256 i notanint shrt 100000 uint -1 ushrt -1 l notanint uc -1 ul -1 chars toolongastring ll notanint unic toolongastring ull -1 b morethan3bytes f notanumber s {unknownfield 104} d notanumber
    }
    if {$::tcl_platform(platform) eq "windows"} {
        lappend testvals wchars toolongastring
    }
    foreach {fld val} $testvals {
        test struct-setnative-value-error-$fld "Setnative field struct bad $fld value" -setup {
            set p [::TestStruct allocate]
            testDll function getTestStruct int {p pointer.::TestStruct}
            getTestStruct $p
        } -cleanup {
            ::TestStruct free $p
        } -body {
            list [catch {::TestStruct setnative $p $fld $val} result] \
                [regexp {not in range|expected.*but got|greater than.*maximum buffer|Field missing} $result] [checkTestStruct [::TestStruct fromnative $p]]
        } -result {1 1 {}}
    }

    ###
    # struct setnative!

    testnumargs struct-setnative! "::TestStruct setnative!" "POINTER FIELD VALUE" "?INDEX?"
    test struct-setnative!-0 "setnative! each field struct" -setup {
        set p [::TestStruct allocate]
        cffi::pointer dispose $p
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct ts
    } -cleanup {
        cffi::pointer safe $p
        ::TestStruct free $p
    } -body {
        dict for {key val} $ts {
            ::TestStruct setnative! $p $key $val
        }
        checkTestStruct [::TestStruct fromnative! $p]
    } -result ""

    test struct-setnative!-error-1 "setnative! NULL pointer" -setup {
        ::cffi::Struct create S {i int}
    } -cleanup {
        S destroy
    } -body {
        S setnative! NULL i 42
    } -result {Pointer is NULL.} -returnCodes error

    ###
    # struct getnativefields
    testnumargs struct-getnativefields "::TestStruct getnativefields" "POINTER FIELDNAMES" "?INDEX?"
    test struct-getnativefields-0 "Empty fieldlist" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        S tonative $p [list c 1 i {2 3} d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {}
    } -result {}
    test struct-getnativefields-1 "full fieldlist" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        S tonative $p [list c 1 i {2 3} d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {c i d}
    } -result {1 {2 3} 4.0}
    test struct-getnativefields-2 "fields out of order" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        S tonative $p [list c 1 i {2 3} d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {d c}
    } -result {4.0 1}
    test struct-getnativefields-3 "indexed" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate 2]
        S tonative $p [list c 1 i {2 3} d 4]
        S tonative $p [list c 10 i {20 30} d 40] 1
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p {d c i} 1
    } -result {40.0 10 {20 30}}
    test struct-getnativefields-error-0 "null pointer" -setup {
        ::cffi::Struct create S {c schar d double }
    } -cleanup {
        S destroy
    } -body {
        S getnativefields NULL {d c}
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test struct-getnativefields-error-1 "wrong type pointer" -setup {
        ::cffi::Struct create S {c schar d double }
    } -cleanup {
        S destroy
    } -body {
        S getnativefields [makeptr 1 ::TestStruct] {d c}
    } -result "Value \"[makeptr 1 ::TestStruct]\" has the wrong type. Pointer type mismatch." -returnCodes error
    test struct-getnativefields-error-2 "unknown field" -setup {
        ::cffi::Struct create S {c schar d double }
        set p [S allocate]
        S tonative $p [list c 1 d 4]
    } -cleanup {
        S free $p
        S destroy
    } -body {
        S getnativefields $p nosuchfield
    } -result {Field "nosuchfield" not found or inaccessible. No such field in struct definition ::cffi::test::S.} -returnCodes error
    test struct-getnativefields-error-3 "unsafe pointer" -body {
        ::TestStruct getnativefields 1^::TestStruct {}
    } -result "Pointer [makeptr 1 ::TestStruct] is not registered." -returnCodes error

    ###
    # struct getnativefields!
    testnumargs struct-getnativefields! "::TestStruct getnativefields!" "POINTER FIELDNAMES" "?INDEX?"
    test struct-getnativefields!-0 "getnativefields! full fieldlist" -setup {
        ::cffi::Struct create S {c schar i int[2] d double }
        set p [S allocate]
        cffi::pointer dispose $p
        S tonative! $p [list c 1 i {2 3} d 4]
    } -cleanup {
        cffi::pointer safe $p
        S free $p
        S destroy
    } -body {
        S getnativefields! $p {c i d}
    } -result {1 {2 3} 4.0}

    test struct-getnativefields!-error-0 "null pointer" -setup {
        ::cffi::Struct create S {c schar d double }
    } -cleanup {
        S destroy
    } -body {
        S getnativefields! NULL {d c}
    } -result {Pointer is NULL.} -returnCodes error

    ###
    # struct new
    testnumargs struct-new "::TestStruct new" "" "?INITIALIZER?"
    test struct-new-0 "struct new" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        S destroy
    } -body {
        set p [S new {c 1 i 2 s 3}]
        list [::cffi::pointer tag $p] [::cffi::pointer isvalid $p] [S fromnative $p] [S free $p]
    } -result [list ::S 1 {c 1 i 2 s 3} {}]

    test struct-new-1 "struct new different field order" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        S free $p
        rename S ""
    } -body {
        set p [S new {i 2 s 3 c 1}]
        S fromnative $p
    } -result {c 1 i 2 s 3}

    test struct-new-2 "struct new with test struct" -setup {
        testDll function getTestStruct int {s {struct.TestStruct out}}
        getTestStruct sval
    } -cleanup {
        ::TestStruct free $p
    } -body {
        set p [::TestStruct new $sval]
        checkTestStruct [::TestStruct fromnative $p]
    } -result ""

    test struct-new-3 "struct new with -clear" -setup {
        cffi::Struct create ::S {c uchar i longlong s short} -clear
    } -cleanup {
        S destroy
    } -body {
        set p [S new]
        list [::cffi::pointer tag $p] [::cffi::pointer isvalid $p] [S fromnative $p] [S free $p]
    } -result [list ::S 1 {c 0 i 0 s 0} {}]

    test struct-new-3 "struct new with default field values" -setup {
        cffi::Struct create ::S {i {int {default 42}} b {double {default 24}}}
    } -cleanup {
        S destroy
    } -body {
        set p [S new]
        list [::cffi::pointer tag $p] [::cffi::pointer isvalid $p] [S fromnative $p] [S free $p]
    } -result [list ::S 1 {i 42 b 24.0} {}]

    test struct-new-error-0 "struct new bad value" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S new {c a i 0 s 0}
    } -result {expected integer but got "a" Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-1 "struct new missing field" -setup {
        cffi::Struct create ::S {c uchar i longlong s short}
    } -cleanup {
        rename S ""
    } -body {
        S new {i 0 s 0}
    } -result {Struct field "c" not found or inaccessible. Field missing in struct dictionary value. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-2 "struct new chars overflow" -setup {
        cffi::Struct create ::S {c chars[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abc}
    } -result {Invalid value "abc". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-6 "struct new unichars overflow" -setup {
        cffi::Struct create ::S {c unichars[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abc}
    } -result {Invalid value "abc". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-6.winchars "struct new winchars overflow" -setup {
        cffi::Struct create ::S {c winchars[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abc}
    } -constraints win -result {Invalid value "abc". String length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-7 "struct new bytes overflow" -setup {
        cffi::Struct create ::S {c bytes[3]}
    } -cleanup {
        rename S ""
    } -body {
        S new {c abcd}
    } -result {Invalid value. Byte array length is greater than specified maximum buffer size. Error converting field ::S.c to a native value.} -returnCodes error

    test struct-new-error-8 "struct new - struct with strings" -body {
        StructWithStrings new [makeStructWithStrings]
    } -result {Invalid value. string type not supported in this struct context. Error converting field ::StructWithStrings.s to a native value.} -returnCodes error

    ###
    # Bug fixes

    test struct-bug-53-0 "Check that command is actually a struct" -body {
        cffi::type info {struct.lindex}
    } -result {Invalid value "lindex". Not a cffi::Struct.} -returnCodes error
    test struct-bug-53-1 "Check that command is actually a struct" -body {
        cffi::type info {struct.nosuchstruct}
    } -result {Struct definition "nosuchstruct" not found or inaccessible. } -returnCodes error
    test struct-bug-53-2 "Check that command is actually a struct" -body {
        cffi::Struct create S {x int}
        proc S {} {}
        cffi::type info {struct.S}
    } -cleanup {
        rename S {}
    } -result {Invalid value "S". Not a cffi::Struct.} -returnCodes error

    #
    # Variable size struct tests

    test struct-varsize-error-0 {Variable size struct must have one more field} -body {
        cffi::Struct create S {a int[n]}
    } -result {Invalid value "int[n]". Field of variable size must be the last and must not be the only field.} -returnCodes error
    test struct-varsize-error-1 {Variable size struct must be last} -body {
        cffi::Struct create S {a int[n] n int}
    } -result {Invalid value "int[n]". Field of variable size must be the last and must not be the only field.} -returnCodes error
    test struct-varsize-error-2 {Variable size count field must be integer} -body {
        cffi::Struct create S {n double a int[n]}
    } -result {Field "n" not found or inaccessible. Could not find referenced count for dynamic array, possibly wrong type or not scalar.} -returnCodes error
    test struct-varsize-error-3 {Arrays of variable size structs not permitted} -setup {
        cffi::Struct create S {n int a int[n]}
    } -cleanup {
        S destroy
    } -body {
        cffi::type info {struct.S[2]}
    } -result {Invalid value "struct.S[2]". Array element types must be fixed size.} -returnCodes error

    test struct-varsize-nested-error-0 {Nested variable size struct must be last} -setup {
        cffi::Struct create S {n int a int[n]}
    } -cleanup {
        S destroy
    } -body {
        cffi::Struct create Outer {s struct.S i int}
    } -result {Invalid value "struct.S". Field of variable size must be the last and must not be the only field.} -returnCodes error
    test struct-varsize-nested-error-2 {Nested variable size struct must not be an array} -setup {
        cffi::Struct create S {n int a int[n]}
        cffi::Struct create Outer {i int s struct.S}
    } -cleanup {
        Outer destroy
        S destroy
    } -body {
        cffi::type info {struct.Outer[2]}
    } -result {Invalid value "struct.Outer[2]". Array element types must be fixed size.} -returnCodes error

    # Test size and alignment with various combination of field alignment order
    test struct-varsize-uchar-int-0 {uchar count int array[0]} -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {count uchar values int[count]}
        cffi::type info struct.S -vlacount 0
    } -result {Size 4 Count -1 Alignment 4 Definition struct.::cffi::test::S BaseSize 4} -match dict
    test struct-varsize-uchar-int-1 {uchar count int array[3]} -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {count uchar values int[count]}
        cffi::type info struct.S -vlacount 3
    } -result {Size 16 Count -1 Alignment 4 Definition struct.::cffi::test::S BaseSize 16} -match dict

    test struct-varsize-int-uchar-0 {int count uchar array[0]} -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {count int values uchar[count]}
        cffi::type info struct.S -vlacount 0
    } -result {Size 4 Count -1 Alignment 4 Definition struct.::cffi::test::S BaseSize 4} -match dict
    test struct-varsize-int-uchar-1 {int count uchar array[3]} -cleanup {
        S destroy
    } -body {
        cffi::Struct create S {count int values uchar[count]}
        cffi::type info struct.S -vlacount 3
    } -result {Size 8 Count -1 Alignment 4 Definition struct.::cffi::test::S BaseSize 8} -match dict

}


::tcltest::cleanupTests
namespace delete cffi::test
