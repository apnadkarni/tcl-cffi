# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# This file contains tests for all cffi::dyncall::Library functionality except the
# function method which has its own file

source [file join [file dirname [info script]] common.tcl]

namespace eval cffi::test {
    set libraryClass ${NS}::dyncall::Library

    proc command_exists {cmd} {
        return [expr {[uplevel #0 namespace which $cmd] eq $cmd}]
    }

    testsubcmd $libraryClass

    test dyncall-Library-new-0 {dyncall::Library new} -body {
        set dll [$libraryClass new $testDllPath]
        set path [$dll path]
        list [command_exists $dll] [$dll destroy] [command_exists $dll] [file normalize $path]
    } -result [list 1 {} 0 $testDllPath]

    test dyncall-Library-new-1 {dyncall::Library new (no argument)} -body {
        set dll [$libraryClass new]
        set path [$dll path]
        list [command_exists $dll] [rename $dll ""] [command_exists $dll] [file normalize $path]
    } -result [list 1 {} 0 [file normalize [info nameofexecutable]]]

    test dyncall-Library-new-error-0 {dyncall::Library new (invalid path)} -body {
        list [catch {
            $libraryClass new nosuchpath
        } result] $result $::errorCode
    } -result [list 1 {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.} {cffi NOT_FOUND {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.}}]

    test dyncall-Library-new-error-1 {dyncall::Library new (extra args)} -body {
        list [catch {
            $libraryClass new $testDllPath extraarg
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Library new DLLPATH"} {TCL WRONGARGS}}

    ####

    test dyncall-Library-create-0 {dyncall::Library create (current namespace)} -body {
        set dll [$libraryClass create dll $testDllPath]
        set path [dll path]
        list $dll [command_exists [namespace current]::dll] [dll destroy] [command_exists [namespace current]::dll] [file normalize $path]
    } -result [list [namespace current]::dll 1 {} 0 $testDllPath]

    test dyncall-Library-create-1 {dyncall::Library create (global namespace)} -body {
        set dll [$libraryClass create ::dll $testDllPath]
        set path [::dll path]
        list $dll [command_exists ::dll] [rename ::dll ""] [command_exists ::dll] [file normalize $path]
    } -result [list ::dll 1 {} 0 $testDllPath]

    test dyncall-Library-create-2 {dyncall::Library create (explicit namespace)} -setup {
        set ns ::cffi::test::ns
        namespace eval $ns {}
    } -cleanup {
        namespace delete $ns
    } -body {
        set dll [$libraryClass create ${ns}::dll $testDllPath]
        set path [${ns}::dll path]
        list $dll [command_exists $dll] [$dll destroy] [command_exists $dll] [file normalize $path]
    } -result [list ::cffi::test::ns::dll 1 {} 0 $testDllPath]

    test dyncall-Library-create-3 {dyncall::Library create (no path argument)} -body {
        set dll [$libraryClass create dll]
        set path [dll path]
        dll destroy
        file tail $path
    } -result [file tail [info nameofexecutable]]

    test dyncall-Library-create-error-0 {dyncall::Library create (invalid path)} -body {
        list [catch {
            $libraryClass create dll nosuchpath
        } result] $result $::errorCode
    } -result [list 1 {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.} {cffi NOT_FOUND {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.}}]

    test dyncall-Library-create-error-1 {dyncall::Library create (extra args)} -body {
        list [catch {
            $libraryClass create dll $testDllPath extraarg
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Library create OBJNAME DLLPATH"} {TCL WRONGARGS}}

    test dyncall-Library-create-error-2 {dyncall::Library create (no args)} -body {
        list [catch {
            $libraryClass create
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Library create OBJNAME DLLPATH"} {TCL WRONGARGS}}

    ####

    test dyncall-Library-path-0 {dyncall::Library path} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        file normalize [dll path]
    } -result $testDllPath

    test dyncall-Library-path-1 {dyncall::Library path (default image)} -setup {
        $libraryClass create dll
    } -cleanup {
        dll destroy
    } -body {
        file normalize [dll path]
    } -result [file normalize [info nameofexecutable]]

    test dyncall-Library-path-error-1 {dyncall::Library path (extra args)} -setup {
        $libraryClass create dll
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            file normalize [dll path xxx]
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "dll path "} {TCL WRONGARGS}}

    ####

    test dyncall-Library-addressof-0 {dyncall::Library addressof} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        dll addressof schar_to_schar
    } -result {^0x[[:xdigit:]]{8,16}$} -match regexp

    test dyncall-Library-addressof-error-0 {dyncall::Library addressof (invalid symbol)} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            dll addressof nosuchsym
        } result] $result $::errorCode
    } -result {1 {Symbol "nosuchsym" not found or inaccessible. } {cffi NOT_FOUND {Symbol "nosuchsym" not found or inaccessible. }}}

    test dyncall-Library-addressof-error-1 {dyncall::Library addressof (no args)} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            dll addressof
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "dll addressof SYMBOL"} {TCL WRONGARGS}}

    test dyncall-Library-addressof-error-2 {dyncall::Library addressof (extra args)} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            dll addressof schar_to_schar extra
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "dll addressof SYMBOL"} {TCL WRONGARGS}}
}

::tcltest::cleanupTests
namespace delete cffi::test
