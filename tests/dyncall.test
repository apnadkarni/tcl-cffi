# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# This file contains tests for all cffi::dyncall::Library functionality except the
# function method which has its own file

source [file join [file dirname [info script]] common.tcl]

# Library tests
namespace eval ${NS}::test {
    set libraryClass ${NS}::dyncall::Library

    proc command_exists {cmd} {
        return [expr {[uplevel #0 namespace which $cmd] eq $cmd}]
    }

    testsubcmd $libraryClass

    test dyncall-Library-new-0 {dyncall::Library new} -body {
        set dll [$libraryClass new $testDllPath]
        set path [$dll path]
        list [command_exists $dll] [$dll destroy] [command_exists $dll] [file normalize $path]
    } -result [list 1 {} 0 $testDllPath]

    test dyncall-Library-new-1 {dyncall::Library new (no argument)} -body {
        set dll [$libraryClass new]
        set path [file normalize [$dll path]]
        if {$::tcl_platform(platform) eq "windows"} {
            set image_path [file normalize [info nameofexecutable]]
        } else {
            set image_path ""
        }
        list [command_exists $dll] [rename $dll ""] [command_exists $dll] [string equal $path $image_path]
    } -result [list 1 {} 0 1]

    test dyncall-Library-new-error-0 {dyncall::Library new (invalid path)} -body {
        list [catch {
            $libraryClass new nosuchpath
        } result] $result $::errorCode
    } -result [list 1 {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.} {cffi NOT_FOUND {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.}}]

    test dyncall-Library-new-error-1 {dyncall::Library new (extra args)} -body {
        list [catch {
            $libraryClass new $testDllPath extraarg
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Library new ?DLLPATH?"} {TCL WRONGARGS}}

    ####

    test dyncall-Library-create-0 {dyncall::Library create (current namespace)} -body {
        set dll [$libraryClass create dll $testDllPath]
        set path [dll path]
        list $dll [command_exists [namespace current]::dll] [dll destroy] [command_exists [namespace current]::dll] [file normalize $path]
    } -result [list [namespace current]::dll 1 {} 0 $testDllPath]

    test dyncall-Library-create-1 {dyncall::Library create (global namespace)} -body {
        set dll [$libraryClass create ::dll $testDllPath]
        set path [::dll path]
        list $dll [command_exists ::dll] [rename ::dll ""] [command_exists ::dll] [file normalize $path]
    } -result [list ::dll 1 {} 0 $testDllPath]

    test dyncall-Library-create-2 {dyncall::Library create (explicit namespace)} -setup {
        set ns ::cffi::test::ns
        namespace eval $ns {}
    } -cleanup {
        namespace delete $ns
    } -body {
        set dll [$libraryClass create ${ns}::dll $testDllPath]
        set path [${ns}::dll path]
        list $dll [command_exists $dll] [$dll destroy] [command_exists $dll] [file normalize $path]
    } -result [list ::cffi::test::ns::dll 1 {} 0 $testDllPath]

    test dyncall-Library-create-3 {dyncall::Library create (no path argument)} -body {
        set dll [$libraryClass create dll]
        set path [file normalize [$dll path]]
        dll destroy
        if {$::tcl_platform(platform) eq "windows"} {
            set image_path [file normalize [info nameofexecutable]]
        } else {
            set image_path ""
        }
        string equal $path $image_path
    } -result 1

    test dyncall-Library-create-error-0 {dyncall::Library create (invalid path)} -body {
        list [catch {
            $libraryClass create dll nosuchpath
        } result] $result $::errorCode
    } -result [list 1 {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.} {cffi NOT_FOUND {Shared library "nosuchpath" not found or inaccessible. Could not load shared library.}}]

    test dyncall-Library-create-error-1 {dyncall::Library create (extra args)} -body {
        list [catch {
            $libraryClass create dll $testDllPath extraarg
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Library create OBJNAME ?DLLPATH?"} {TCL WRONGARGS}}

    test dyncall-Library-create-error-2 {dyncall::Library create (no args)} -body {
        list [catch {
            $libraryClass create
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Library create OBJNAME ?DLLPATH?"} {TCL WRONGARGS}}

    ####

    test dyncall-Library-path-0 {dyncall::Library path} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        file normalize [dll path]
    } -result $testDllPath

    test dyncall-Library-path-1 {dyncall::Library path (default image)} -setup {
        $libraryClass create dll
    } -cleanup {
        dll destroy
    } -body {
        if {$::tcl_platform(platform) eq "windows"} {
            set image_path [file normalize [info nameofexecutable]]
        } else {
            set image_path ""
        }
        string equal [file normalize [dll path]] $image_path
    } -result 1

    test dyncall-Library-path-error-1 {dyncall::Library path (extra args)} -setup {
        $libraryClass create dll
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            file normalize [dll path xxx]
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "dll path "} {TCL WRONGARGS}}

    ####

    test dyncall-Library-addressof-0 {dyncall::Library addressof} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        dll addressof schar_to_schar
    } -result {^0x[[:xdigit:]]{8,16}$} -match regexp

    test dyncall-Library-addressof-error-0 {dyncall::Library addressof (invalid symbol)} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            dll addressof nosuchsym
        } result] $result $::errorCode
    } -result {1 {Symbol "nosuchsym" not found or inaccessible. } {cffi NOT_FOUND {Symbol "nosuchsym" not found or inaccessible. }}}

    test dyncall-Library-addressof-error-1 {dyncall::Library addressof (no args)} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            dll addressof
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "dll addressof SYMBOL"} {TCL WRONGARGS}}

    test dyncall-Library-addressof-error-2 {dyncall::Library addressof (extra args)} -setup {
        $libraryClass create dll $testDllPath
    } -cleanup {
        dll destroy
    } -body {
        list [catch {
            dll addressof schar_to_schar extra
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "dll addressof SYMBOL"} {TCL WRONGARGS}}
}

# Symbols tests
namespace eval ${NS}::test  {
    set symbolsClass ${NS}::dyncall::Symbols

    test dyncall-Symbols-new-0 {dyncall::Symbols new} -body {
        set dll [$symbolsClass new $testDllPath]
        list [command_exists $dll] [$dll destroy] [command_exists $dll]
    } -result [list 1 {} 0]

    # A normal build of tclsh does not contain an export table hence the constraint
    test dyncall-Symbols-new-1 {dyncall::Symbols new (no argument)} -constraints {
        disabled
    } -body {
        set dll [$symbolsClass new]
        set path [$dll path]
        list [command_exists $dll] [rename $dll ""] [command_exists $dll] [file normalize $path]
    } -result [list 1 {} 0 [file normalize [info nameofexecutable]]]

    test dyncall-Symbols-new-error-0 {dyncall::Symbols new (invalid path)} -body {
        list [catch {
            $symbolsClass new nosuchpath
        } result] $result $::errorCode
    } -result [list 1 {Symbols container "nosuchpath" not found or inaccessible. Could not find file or export table in file.} {cffi NOT_FOUND {Symbols container "nosuchpath" not found or inaccessible. Could not find file or export table in file.}}]

    test dyncall-Symbols-new-error-1 {dyncall::Symbols new (extra args)} -body {
        list [catch {
            $symbolsClass new $testDllPath extraarg
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Symbols new ?DLLPATH?"} {TCL WRONGARGS}}

    ####

    test dyncall-Symbols-create-0 {dyncall::Symbols create (current namespace)} -body {
        set dll [$symbolsClass create dll $testDllPath]
        list $dll [command_exists [namespace current]::dll] [dll destroy] [command_exists [namespace current]::dll] 
    } -result [list [namespace current]::dll 1 {} 0]

    test dyncall-Symbols-create-1 {dyncall::Symbols create (global namespace)} -body {
        set dll [$symbolsClass create ::dll $testDllPath]
        list $dll [command_exists ::dll] [rename ::dll ""] [command_exists ::dll]
    } -result [list ::dll 1 {} 0]

    test dyncall-Symbols-create-2 {dyncall::Symbols create (explicit namespace)} -setup {
        set ns ::cffi::test::ns
        namespace eval $ns {}
    } -cleanup {
        namespace delete $ns
    } -body {
        set dll [$symbolsClass create ${ns}::dll $testDllPath]
        list $dll [command_exists $dll] [$dll destroy] [command_exists $dll]
    } -result [list ::cffi::test::ns::dll 1 {} 0]

    # A normal build of tclsh does not contain an export table hence the constraint
    test dyncall-Symbols-create-3 {dyncall::Symbols create (no path argument)} -constraints {
        disabled
    } -body {
        set dll [$symbolsClass create dll]
        set path [dll path]
        dll destroy
        file tail $path
    } -result [file tail [info nameofexecutable]]

    test dyncall-Symbols-create-error-0 {dyncall::Symbols create (invalid path)} -body {
        list [catch {
            $symbolsClass create dll nosuchpath
        } result] $result $::errorCode
    } -result [list 1 {Symbols container "nosuchpath" not found or inaccessible. Could not find file or export table in file.} {cffi NOT_FOUND {Symbols container "nosuchpath" not found or inaccessible. Could not find file or export table in file.}}]

    test dyncall-Symbols-create-error-1 {dyncall::Symbols create (extra args)} -body {
        list [catch {
            $symbolsClass create dll $testDllPath extraarg
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Symbols create OBJNAME ?DLLPATH?"} {TCL WRONGARGS}}

    test dyncall-Symbols-create-error-2 {dyncall::Symbols create (no args)} -body {
        list [catch {
            $symbolsClass create
        } result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::dyncall::Symbols create OBJNAME ?DLLPATH?"} {TCL WRONGARGS}}

    ###
    # Symbols count
    testnumargs dyncall-Symbols-count "testSyms count" "" ""
    test dyncall-Symbols-count-0 {dyncall::Symbols count} -body {
        set count [testSyms count]
        # Platform and compiler dependent - TBD
        puts count=$count
        expr {$count > 250}
    } -result 1

    ###
    # Symbols index
    testnumargs dyncall-Symbols-index "testSyms index" "INDEX" ""
    test dyncall-Symbols-index-0 {dyncall::Symbols index} -body {
        set sym [testSyms index 1]
        puts sym=$sym
        expr {$sym in {binary_out dl_iterate_phdr _stdcalltest@16}}
    } -result 1
    test dyncall-Symbols-index-1 {dyncall::Symbols index} -body {
        set count [testSyms count]
        for {set i 0} {$i < $count} {incr i} {
            catch {
                testSyms index $i
            } result
            puts "$i: $result"
        }
        testSyms index [expr {[testSyms count]-1}]
    } -result [expr {$::tcl_platform(platform) eq "windows" ? "ushort_to_void" : "uchar_array_out"}]
    test dyncall-Symbols-index-error-0 "dyncall::Symbols index - out of range" -body {
        testSyms index [testSyms count]
    } -result {Symbol index "*" not found or inaccessible. No symbol at specified index.} -returnCodes error -match glob
    test dyncall-Symbols-index-error-1 "dyncall::Symbols index - negative" -body {
        testSyms index -1
    } -result {Symbol index "-1" not found or inaccessible. No symbol at specified index.} -returnCodes error

    ###
    # Symbols ataddress
    testnumargs dyncall-Symbols-ataddress "testSyms ataddress" "ADDRESS" ""
    test dyncall-Symbols-ataddress-0 "Symbols ataddress" -body {
        # IMPORTANT: use a function that the linker cannot combine with another
        set addr [testDll addressof getTestStruct]
        testSyms ataddress $addr
    } -result getTestStruct
    test dyncall-Symbols-ataddress-error-0 "Symbols ataddress" -body {
        set addr [testDll addressof getTestStruct]
        testSyms ataddress [expr {$addr+1}]
    } -result "Address \"*\" not found or inaccessible. No symbol at specified address or library not loaded." -returnCodes error -match glob
}

::tcltest::cleanupTests
namespace delete cffi::test
