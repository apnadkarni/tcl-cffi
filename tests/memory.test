# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.
#
# Tests for the cffi::memory command

source [file join [file dirname [info script]] common.tcl]

# NOTE: use fully qualified command name since Tcl also has a
# command called memory

namespace eval cffi::test {
    testsubcmd ::cffi::memory
    testnumargs memory-allocate "cffi::memory allocate" "SIZE" "?TAG?"

    test memory-allocate-0 {Allocate 1 byte untagged} -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        unset -nocomplain p
        set p [cffi::memory allocate 1]
    } -result {^0x[[:xdigit:]]{8,16}\^$} -match regexp

    test memory-allocate-1 {Allocate 1 byte tagged} -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        unset -nocomplain p
        set p [cffi::memory allocate 1 TAG]
    } -result {^0x[[:xdigit:]]{8,16}\^::cffi::test::TAG$} -match regexp


    foreach {type val} [array get testValues] {
        if {$type ni {string unistring winstring binary}} {
            test memory-allocate-$type-0 "allocate $type" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                cffi::memory set $p $type $val
                cffi::memory get $p $type
            } -result $val
            if {$type in [list {*}$numericTypes struct.::StructValue]} {
                # In array tests, use [lindex $type 0] since testValues contains
                # "pointer unsafe" and we only want pointer
                test memory-allocate-$type-array-0 "allocate $type array" -setup {
                    unset -nocomplain p
                    set p [cffi::memory allocate $type\[2\]]
                } -cleanup {
                    if {[info exists p]} {cffi::memory free $p}
                } -body {
                    cffi::memory set $p $type\[2\] [list $val $val]
                    cffi::memory get $p $type\[2\]
                } -result [list $val $val]
            }
        }
    }

    test memory-allocate-error-0 {Allocate zero bytes} -body {
        list [catch {cffi::memory allocate 0} result] $result $::errorCode
    } -result {1 {Invalid value "0". Allocation size argument must be a positive integer or a fixed size type specification.} {cffi INVALID_VALUE {Invalid value "0". Allocation size argument must be a positive integer or a fixed size type specification.}}}

    test memory-allocate-error-1 {Missing args} -body {
        list [catch {cffi::memory allocate} result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::memory allocate SIZE ?TAG?"} {TCL WRONGARGS}}

    test memory-allocate-error-2 {Extra args} -body {
        list [catch {cffi::memory allocate 0 TAG extra} result] $result $::errorCode
    } -result {1 {wrong # args: should be "cffi::memory allocate SIZE ?TAG?"} {TCL WRONGARGS}}

    test memory-allocate-badtype-0 "allocate bad type" -body {
        cffi::memory allocate badtype
    } -result {Invalid value "badtype". Allocation size argument must be a positive integer or a fixed size type specification.} -returnCodes error

    test memory-allocate-badtype-1 "allocate bad type - void" -body {
        cffi::memory allocate void
    } -result {Invalid value "void". Allocation size argument must be a positive integer or a fixed size type specification.} -returnCodes error

    test memory-allocate-badtype-2 "allocate varsize" -setup {
        cffi::Struct create S {n int a uchar[n]}
    } -cleanup {
        S destroy
    } -body {
        cffi::memory allocate struct.S
    } -result {Invalid value "struct.S". Allocation size argument must be a positive integer or a fixed size type specification.} -returnCodes error

    ###

    testnumargs memory-free "cffi::memory free" "POINTER"

    test memory-free-0 {free null pointer} -body {
        cffi::memory free 0x0^
    } -result ""

    test memory_free-error-0 {Double free} -setup {
        unset -nocomplain p
        set p [cffi::memory allocate 1]
        cffi::memory free $p
    } -body {
        list [catch {cffi::memory free $p} result] $result $::errorCode
    } -result {1 {Invalid value*Pointer validation failed: not registered.} {cffi INVALID_VALUE {Invalid value*Pointer validation failed: not registered.}}} -match glob

    ###

    testnumargs memory-tobinary "cffi::memory tobinary" "POINTER SIZE" "?OFFSET?"
    testnumargs memory-tobinary! "cffi::memory tobinary!" "POINTER SIZE"  "?OFFSET?"
    testnumargs memory-frombinary "cffi::memory frombinary" "BINARY" "?TAG?"

    test memory-binary-0 {To/From binary - safe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        set p [cffi::memory frombinary $bin]
        binary scan [cffi::memory tobinary $p [string length $bin]] d3 bin2
        set bin2
    } -result {1.0 2.0 3.0}

    test memory-binary-1 {To/From tobinary! - unsafe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        set p [cffi::memory frombinary $bin]
        cffi::pointer dispose $p; # Make unsafe
        binary scan [cffi::memory tobinary! $p [string length $bin]] d3 bin2
        set bin2
    } -result {1.0 2.0 3.0}

    test memory-binary-2 {To/From tobinary - unsafe} -body {
        cffi::memory tobinary [makeptr 1] 1
    } -result "Invalid value \"[makeptr 1]\". Pointer validation failed: not registered." -returnCodes error

    test memory-binary-3 {To/From tobinary! - unsafe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        set p [cffi::memory frombinary $bin]
        cffi::pointer dispose $p
        binary scan [cffi::memory tobinary! $p [string length $bin]] d3 bin2
        set bin2
    } -result {1.0 2.0 3.0}
    test memory-binary-4 {To/From binary offset - safe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        set p [cffi::memory frombinary $bin]
        set len [string length $bin]
        set off [expr {$len/3}]
        incr len -$off
        binary scan [cffi::memory tobinary $p $len $off] d2 bin2
        set bin2
    } -result {2.0 3.0}
    test memory-binary-5 {To/From tobinary! offset - unsafe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        set p [cffi::memory frombinary $bin]
        set len [string length $bin]
        set off [expr {$len/3}]
        binary scan [cffi::memory tobinary! $p $len $off] d2 bin2
        set bin2
    } -result {2.0 3.0}
    test memory-binary-6 {To/From tobinary! offset negative - unsafe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        set p [cffi::memory frombinary $bin]
        set len [string length $bin]
        set off [expr {$len/3}]
        binary scan [cffi::memory tobinary! [pointer_unsafe_add $p $off] $len -$off] d2 bin2
        set bin2
    } -result {1.0 2.0}

    test memory-tobinary-error-0 "tobinary null pointer" -body {
        cffi::memory tobinary 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error -match regexp
    test memory-tobinary!-error-0 "tobinary! null pointer" -body {
        cffi::memory tobinary! 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test memory-tobinary-error-1 {To/From binary offset negative - safe} -setup {
        set bin [binary format ddd 1.0 2.0 3.0]
        unset -nocomplain p
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        set p [cffi::memory frombinary $bin]
        cffi::memory tobinary $p $len -1
        set bin2
    } -result {Invalid value "-1". Negative offsets are not allowed for safe pointers.} -returnCodes error

    ###

    testnumargs memory-tostring "cffi::memory tostring" "POINTER" "?ENCODING? ?OFFSET?"
    testnumargs memory-tostring! "cffi::memory tostring" "POINTER" "?ENCODING? ?OFFSET?"
    testnumargs memory-towinstring "cffi::memory towinstring" "POINTER" "?OFFSET?" -constraints win
    testnumargs memory-tounistring "cffi::memory tounistring" "POINTER" "?OFFSET?"
    testnumargs memory-fromstring "cffi::memory fromstring" "STRING" "?ENCODING?"
    testnumargs memory-fromwinstring "cffi::memory fromwinstring" "STRING" "" -constraints win
    set num -1
    test memory-string-[incr num] "To/from string - safe, no optional args" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        list \
            [cffi::pointer isvalid $p] \
            [cffi::memory tostring $p] \
            [cffi::memory free $p]
    } -result [list 1 abc {}]
    test memory-string!-$num "To/from string! - safe, no optional args" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        list \
            [cffi::pointer isvalid $p] \
            [cffi::memory tostring! $p] \
            [cffi::memory free $p]
    } -result [list 1 abc {}]
    test memory-string-[incr num] "To/from string - unsafe, no optional args" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::pointer dispose $p
        list \
            [cffi::pointer isvalid $p] \
            [catch {cffi::memory tostring $p} result] \
            [cffi::pointer compare $p [cffi::pointer safe $p]] \
            [cffi::memory free $p]
    } -result [list 0 1 1 {}]
    test memory-string!-$num "To/from string! - unsafe, no optional args" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::pointer dispose $p
        list \
            [cffi::pointer isvalid $p] \
            [cffi::memory tostring! $p] \
            [cffi::pointer compare $p [cffi::pointer safe $p]] \
            [cffi::memory free $p]
    } -result [list 0 abc 1 {}]
    # Encoding tests
    # Note: do not include ascii for jis0208 encoding tests.
    # See https://core.tcl-lang.org/tcl/tktview/9bad909c6ed4691bcad1886d710a923791a524a2
    set repeat 100000
    foreach {val encoding} \
        [list \
             "abc" {} \
             "" {} \
             "abc\xe0\xe1\xe2" cp1252 \
             "\u543e" jis0208 \
             "\u543e" unicode \
            ] \
        {
            test memory-string-[incr num] "To/from string - safe $encoding" -body {
                unset -nocomplain p
                set p [cffi::memory fromstring $val $encoding]
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tostring $p $encoding] \
                    [cffi::memory free $p]
            } -result [list 1 $val {}]
            test memory-unistring-$num "To/from unistring - safe" -body {
                unset -nocomplain p
                set p [cffi::memory fromunistring $val]
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tounistring $p] \
                    [cffi::memory free $p]
            } -result [list 1 $val {}]
            test memory-winstring-$num "To/from winstring - safe" -body {
                unset -nocomplain p
                set p [cffi::memory fromwinstring $val]
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory towinstring $p] \
                    [cffi::memory free $p]
            } -result [list 1 $val {}] -constraints win

            test memory-string!-$num "To/from string! - unsafe $encoding" -body {
                unset -nocomplain p
                set p [cffi::memory fromstring $val $encoding]
                cffi::pointer dispose $p
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tostring! $p $encoding] \
                    [cffi::pointer compare $p [cffi::pointer safe $p]] \
                    [cffi::memory free $p]
            } -result [list 0 $val 1 {}]
            test memory-unistring!-$num "To/from unistring! - unsafe" -body {
                unset -nocomplain p
                set p [cffi::memory fromunistring $val]
                cffi::pointer dispose $p
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tounistring! $p] \
                    [cffi::pointer compare $p [cffi::pointer safe $p]] \
                    [cffi::memory free $p]
            } -result [list 0 $val 1 {}]
            test memory-winstring!-$num "To/from winstring! - unsafe" -body {
                unset -nocomplain p
                set p [cffi::memory fromwinstring $val]
                cffi::pointer dispose $p
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory towinstring! $p] \
                    [cffi::pointer compare $p [cffi::pointer safe $p]] \
                    [cffi::memory free $p]
            } -result [list 0 $val 1 {}] -constraints win

            test memory-string-[incr num] "To/from long string - safe $encoding" -body {
                unset -nocomplain p
                set p [cffi::memory fromstring [string repeat $val $repeat] $encoding]
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tostring $p $encoding] \
                    [cffi::memory free $p]
            } -result [list 1 [string repeat $val $repeat] {}]
            test memory-unistring-$num "To/from long unistring - safe" -body {
                unset -nocomplain p
                set p [cffi::memory fromunistring [string repeat $val $repeat]]
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tounistring $p] \
                    [cffi::memory free $p]
            } -result [list 1 [string repeat $val $repeat] {}]
            test memory-winstring-$num "To/from long winstring - safe" -body {
                unset -nocomplain p
                set p [cffi::memory fromwinstring [string repeat $val $repeat]]
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory towinstring $p] \
                    [cffi::memory free $p]
            } -result [list 1 [string repeat $val $repeat] {}] -constraints win

            test memory-string!-$num "To/from long string! - unsafe $encoding" -body {
                unset -nocomplain p
                set p [cffi::memory fromstring [string repeat $val $repeat] $encoding]
                cffi::pointer dispose $p
                list \
                    [cffi::pointer isvalid $p] \
                    [cffi::memory tostring! $p $encoding] \
                    [cffi::pointer compare $p [cffi::pointer safe $p]] \
                    [cffi::memory free $p]
            } -result [list 0 [string repeat $val $repeat] 1 {}]
    }
    test memory-string-[incr num] "memory tostring offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::memory tostring $p 1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result bc
    test memory-unistring-$num "memory tounistring offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromunistring abc]
        cffi::memory tounistring $p 1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result bc
    test memory-winstring-$num "memory towinstring offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromwinstring abc]
        cffi::memory towinstring $p 1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result bc -constraints win
    test memory-string-[incr num] "memory tostring encoding offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::memory tostring $p ascii 1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result bc
    test memory-string-[incr num] "memory tostring! offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::memory tostring! [pointer_unsafe_add $p 1] 1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result c
    test memory-string-[incr num] "memory tostring! encoding offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::memory tostring! [pointer_unsafe_add $p 1] ascii 1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result c
    test memory-string-[incr num] "memory tostring! negative offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::memory tostring! [pointer_unsafe_add $p 1] -1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result abc
    test memory-unistring-$num "memory tounistring! negative offset" -body {
        unset -nocomplain p
        if {[lindex [split [info tclversion] .] 0] > 8} {
            set unichar_len 4
        } else {
            set unichar_len 2
        }
        set p [cffi::memory fromunistring abc]
        cffi::memory tounistring! [pointer_unsafe_add $p $unichar_len] -1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result abc
    test memory-winstring-$num "memory towinstring! negative offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromwinstring abc]
        cffi::memory towinstring! [pointer_unsafe_add $p 2] -1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result abc -constraints win

    test memory-tostring-error-0 "tostring null pointer" -body {
        cffi::memory tostring 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error -match regexp
    test memory-tounistring-error-0 "tounistring null pointer" -body {
        cffi::memory tounistring 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error -match regexp
    test memory-towinstring-error-0 "towinstring null pointer" -body {
        cffi::memory towinstring 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error -match regexp -constraints win
    test memory-tostring-error-1 "memory tostring negative offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromstring abc]
        cffi::memory tostring $p -1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result {Invalid value. Negative offsets are not allowed for safe pointers.} -returnCodes error
    test memory-tounistring-error-1 "memory tounistring negative offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromunistring abc]
        cffi::memory tounistring $p -1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result {Invalid value. Negative offsets are not allowed for safe pointers.} -returnCodes error
    test memory-towinstring-error-1 "memory towinstring negative offset" -body {
        unset -nocomplain p
        set p [cffi::memory fromwinstring abc]
        cffi::memory towinstring $p -1
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -result {Invalid value. Negative offsets are not allowed for safe pointers.} -returnCodes error -constraints win

    test memory-tostring!-error-0 "tostring! null pointer" -body {
        cffi::memory tostring! 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error
    test memory-tounistring!-error-0 "tounistring! null pointer" -body {
        cffi::memory tounistring! 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error -match regexp
    test memory-towinstring!-error-0 "towinstring! null pointer" -body {
        cffi::memory towinstring! 0x0^ 1
    } -result {Invalid value. Pointer is NULL.} -returnCodes error -match regexp -constraints win

    ###
    # memory fill
    testnumargs memory-fill "::cffi::memory fill" "POINTER BYTEVALUE COUNT" "?OFFSET?"
    test memory-fill-0 {memory fill} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory fill $p 1 2
        cffi::memory tobinary $p 2
    } -result \x01\x01
    test memory-fill-1 {memory fill 0 bytes} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory fill $p 1 0
        cffi::memory tobinary $p 2
    } -result \x00\xff
    test memory-fill-2 {memory fill lowest value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory fill $p 0 2
        cffi::memory tobinary $p 2
    } -result \x00\x00
    test memory-fill-3 {memory fill highest value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory fill $p 255 2
        cffi::memory tobinary $p 2
    } -result \xFF\xFF
    test memory-fill-4 {memory fill at offset} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x01\x02\x03]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory fill $p 255 2 1
        cffi::memory tobinary $p 3
    } -result \x01\xff\xff

    test memory-fill-error-0 {memory fill negative bytes} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        list \
            [catch {cffi::memory fill $p 1 -1} result] \
            $result \
            [cffi::memory tobinary $p 2]
    } -result [list 1 {Value -1 not in range. Must be within [0,2147483647].} \x00\xFF]
    test memory-fill-error-1 {memory fill > int-max bytes} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        list \
            [catch {cffi::memory fill $p 1 2147483648} result] \
            $result \
            [cffi::memory tobinary $p 2]
    } -result [list 1 {Value 2147483648 not in range. Must be within [0,2147483647].} \x00\xFF]
    test memory-fill-error-2 {memory fill negative value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        list \
            [catch {cffi::memory fill $p -1 1} result] \
            $result \
            [cffi::memory tobinary $p 2]
    } -result [list 1 {Value -1 not in range. Must be within [0,255].} \x00\xFF]
    test memory-fill-error-3 {memory fill too high value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        list \
            [catch {cffi::memory fill $p 256 1} result] \
            $result \
            [cffi::memory tobinary $p 2]
    } -result [list 1 {Value 256 not in range. Must be within [0,255].} \x00\xFF]
    test memory-fill-error-4 "memory fill - NULL pointer" -body {
        cffi::memory fill NULL 0 1
    } -result "*Pointer is NULL*" -match glob -returnCodes error
    test memory-fill-error-5 {memory fill at negative offset} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x01\x02\x03]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        list \
            [catch {cffi::memory fill $p 255 2 -1} emsg] \
            $emsg \
            [cffi::memory tobinary $p 3]
    } -result [list 1 {Invalid value "-1". Negative offsets are not allowed for safe pointers.} \x01\x02\x03]

    #
    # memory fill!
    testnumargs memory-fill! "::cffi::memory fill!" "POINTER BYTEVALUE COUNT" "?OFFSET?"
    test memory-fill!-0 {memory fill!} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        cffi::memory fill! $p 1 2
        cffi::memory tobinary! $p 2
    } -result \x01\x01
    test memory-fill!-1 {memory fill! 0 bytes} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        cffi::memory fill! $p 1 0
        cffi::memory tobinary! $p 2
    } -result \x00\xff
    test memory-fill!-2 {memory fill! lowest value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        cffi::memory fill! $p 0 2
        cffi::memory tobinary! $p 2
    } -result \x00\x00
    test memory-fill!-3 {memory fill! highest value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        cffi::memory fill! $p 255 2
        cffi::memory tobinary! $p 2
    } -result \xFF\xFF
    test memory-fill!-4 {memory fill! at offset} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x01\x02\x03]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        cffi::memory fill! $p 255 2 1
        cffi::memory tobinary! $p 3
    } -result \x01\xff\xff
    test memory-fill!-5 {memory fill! at negative offset} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x01\x02\x03]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory fill! [pointer_unsafe_add $p 1] 255 2 -1
        cffi::memory tobinary! $p 3
    } -result \xff\xff\x03

    test memory-fill!-error-0 {memory fill! negative bytes} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        list \
            [catch {cffi::memory fill! $p 1 -1} result] \
            $result \
            [cffi::memory tobinary! $p 2]
    } -result [list 1 {Value -1 not in range. Must be within [0,2147483647].} \x00\xFF]
    test memory-fill!-error-1 {memory fill! > int-max bytes} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        list \
            [catch {cffi::memory fill! $p 1 2147483648} result] \
            $result \
            [cffi::memory tobinary! $p 2]
    } -result [list 1 {Value 2147483648 not in range. Must be within [0,2147483647].} \x00\xFF]
    test memory-fill!-error-2 {memory fill! negative value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        list \
            [catch {cffi::memory fill! $p -1 1} result] \
            $result \
            [cffi::memory tobinary! $p 2]
    } -result [list 1 {Value -1 not in range. Must be within [0,255].} \x00\xFF]
    test memory-fill!-error-3 {memory fill! too high value} -setup {
        unset -nocomplain p
        set p [cffi::memory frombinary \x00\xFF]
        cffi::pointer dispose $p
    } -cleanup {
        if {[info exists p]} {
            cffi::pointer safe $p
            cffi::memory free $p
        }
    } -body {
        list \
            [catch {cffi::memory fill! $p 256 1} result] \
            $result \
            [cffi::memory tobinary! $p 2]
    } -result [list 1 {Value 256 not in range. Must be within [0,255].} \x00\xFF]
    test memory-fill!-error-4 "memory fill! - NULL pointer" -body {
        cffi::memory fill! NULL 0 1
    } -result "*Pointer is NULL*" -match glob -returnCodes error

    #
    # memory set/get
    testnumargs memory-get "cffi::memory get" "POINTER TYPE" "?INDEX?"
    testnumargs memory-set "cffi::memory set" "POINTER TYPE VALUE" "?INDEX?"

    foreach type [array names testValues] {
        test memory-set-$type-null-0 "set $type NULL" -body {
            cffi::memory set NULL $type $testValues($type)
        } -result "Invalid value. Pointer is NULL." -returnCodes error
        test memory-set-$type-unregistered-0 "set $type unregistered" -body {
            cffi::memory set [makeptr 1] $type $testValues($type)
        } -result "Invalid value \"[makeptr 1]\". Pointer validation failed: not registered." -returnCodes error
        test memory-get-$type-null-0 "get $type NULL" -body {
            cffi::memory get NULL $type
        } -result "Invalid value. Pointer is NULL." -returnCodes error
        test memory-get-$type-unregistered-0 "get $type unregistered" -body {
            cffi::memory get [makeptr 1] $type
        } -result "Invalid value \"[makeptr 1]\". Pointer validation failed: not registered." -returnCodes error
        test memory-set!-$type-null-0 "set! $type NULL" -body {
            cffi::memory set! NULL $type $testValues($type)
        } -result {Invalid value. Pointer is NULL.} -returnCodes error
        test memory-get!-$type-null-0 "get! $type NULL" -body {
            cffi::memory get! NULL $type
        } -result {Invalid value. Pointer is NULL.} -returnCodes error
    }
    foreach {type val} [array get testValues] {
        if {$type ni {string unistring winstring binary}} {
            test memory-set-get-$type-0 "set/get $type" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                cffi::memory set $p $type $val
                cffi::memory get $p $type
            } -result $val

            test memory-set-get-$type-alias-0 "set/get $type - aliased" -setup {
                cffi::alias clear
                cffi::alias define ALIAS $type
                unset -nocomplain p
                set p [cffi::memory allocate ALIAS]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
                cffi::alias clear
            } -body {
                cffi::memory set $p ALIAS $val
                cffi::memory get $p ALIAS
            } -result $val

            test memory-set-$type-badindex-0 "set $type badindex" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                cffi::memory set $p $type $val notanint
            } -result {expected integer but got "notanint"} -returnCodes error

            if {[info exists badValues($type)]} {
                test memory-set-$type-badvalue-0 "set $type bad value" -setup {
                    unset -nocomplain p
                    set p [cffi::memory allocate $type]
                } -cleanup {
                    if {[info exists p]} {cffi::memory free $p}
                } -body {
                    cffi::memory set $p $type $val
                    list [cffi::memory get $p $type] \
                        [catch {cffi::memory set $p $type $badValues($type)} errorMsg] \
                        [regexp {expected.*but got|Invalid value|missing.*key} $errorMsg] \
                        [cffi::memory get $p $type]
                } -result [list $val 1 1 $val]

            }

            test memory-get-$type-badindex-0 "get $type - bad index" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                cffi::memory get $p $type notanint
            } -result {expected integer but got "notanint"} -returnCodes error

            test memory-set!-get!-$type-0 "set!/get! $type" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type]
                cffi::pointer dispose $p;#Make unsafe
            } -cleanup {
                if {[info exists p]} {
                    cffi::pointer safe $p
                    cffi::memory free $p
                }
            } -body {
                cffi::memory set! $p $type $val
                cffi::memory get! $p $type
            } -result $val
        }
        if {$type in $numericTypes} {
            test memory-set-get-$type-1 "set/get $type index" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type\[2\]]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                cffi::memory set $p $type\[2\] [list 1 $val]
                cffi::memory get $p $type 1
            } -result $val

            test memory-set-get-$type-array-0 "set/get $type array" -setup {
                unset -nocomplain p
                set p [cffi::memory allocate $type\[2\]]
            } -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                cffi::memory set $p $type\[2\] [list 1 $val]
                cffi::memory get $p $type\[2\]
            } -result [list [expr {$type in $realTypes ? 1.0 : 1}] $val]
        }
    }
    set type struct.::StructValue
    set val $testValues($type)
    test memory-set-get-$type-array-0 "set/get $type array" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate $type\[2\]]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory set $p $type\[2\] [list {} $val]
        cffi::memory get $p $type\[2\]
    } -result [list {c 0 i 0} $val]
    test memory-set-get-$type-array-0 "set/get $type index" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate $type\[2\]]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory set $p $type\[2\] [list {} $val]
        cffi::memory get $p $type 1
    } -result $val

    set matrix {string unistring binary}
    if {[onwindows]} {
       lappend matrix winstring
    }
    foreach type $matrix {
        test memory-set-$type-0 "set $type" -setup {
            unset -nocomplain p
            set p [cffi::memory allocate 8]; # Enough to hold a pointer
        } -cleanup {
            if {[info exists p]} {cffi::memory free $p}
        } -body {
            cffi::memory set $p $type $testValues($type)
        } -result "Invalid value*" -returnCodes error -match glob
    }
    test memory-get-string-0 "get string" -setup {
        set s [cffi::memory fromstring $testValues(string)]
        unset -nocomplain p
        set p [cffi::memory allocate [dict get [cffi::type info pointer field] Size]]
        cffi::memory set $p pointer $s
    } -cleanup {
        if {[info exists s]} {cffi::memory free $s}
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory get $p string
    } -result $testValues(string)
    test memory-get-string-1 "get string utf-8" -setup {
        set s [cffi::memory fromstring $testValues(unistring) utf-8]
        unset -nocomplain p
        set p [cffi::memory allocate [dict get [cffi::type info pointer field] Size]]
        cffi::memory set $p pointer $s
    } -cleanup {
        if {[info exists s]} {cffi::memory free $s}
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory get $p string.utf-8
    } -result $testValues(unistring)
    test memory-get-unistring-0 "get unistring" -setup {
        set enc [expr {$unicharSize == 4 ? "utf-32" : "unicode"}]
        set s [cffi::memory fromstring $testValues(unistring) $enc]
        unset -nocomplain p
        set p [cffi::memory allocate [dict get [cffi::type info pointer field] Size]]
        cffi::memory set $p pointer $s
    } -cleanup {
        if {[info exists s]} {cffi::memory free $s}
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory get $p unistring
    } -result $testValues(unistring)

    if {[onwindows]} {
        test memory-get-winstring-0 "get winstring" -setup {
            unset -nocomplain s
            unset -nocomplain p
            set s [cffi::memory fromstring $testValues(winstring) [expr {[package vsatisfies [info tclversion] 9] ? "utf-16le" : "unicode"}]]
            set p [cffi::memory allocate [dict get [cffi::type info pointer field] Size]]
            cffi::memory set $p pointer $s
        } -cleanup {
            if {[info exists s]} {cffi::memory free $s}
            if {[info exists p]} {cffi::memory free $p}
        } -constraints win -body {
            cffi::memory get $p winstring
        } -result $testValues(winstring)

        test memory-get-winchars-multisz-0 "Get a multisz list" -setup {
            set s [cffi::memory new {bytes[100]} "A\x00 \x00B\x00\x00\x00C\x00\x00\x00D\x00E\x00\x00\x00\x00\x00"]
            set p [cffi::memory allocate [dict get [cffi::type info pointer field] Size]]
            cffi::memory set $p pointer $s
        } -cleanup {
            if {[info exists s]} {cffi::memory free $s}
            if {[info exists p]} {cffi::memory free $p}
        } -constraints win -body {
            cffi::memory get $p {winstring multisz}
        } -result [list {A B} C DE]
    }

    test memory-get-binary-0 "set $type" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate 8]; # Enough to hold a pointer
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory get $p binary
    } -result "Invalid value*" -returnCodes error -match glob

    test memory-set-badtype-0 "set bad type" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate 8]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory set $p badtype 0
    } -result {Invalid value "badtype". Invalid base type.} -returnCodes error
    test memory-set-badtype-1 "set bad type - void" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate 8]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory set $p void 0
    } -result {Invalid value "void". The specified type is not valid for the type declaration context.} -returnCodes error

    test memory-get-badtype-0 "get bad type" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate 8]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory get $p badtype
    } -result {Invalid value "badtype". Invalid base type.} -returnCodes error
    test memory-get-badtype-1 "get bad type - void" -setup {
        unset -nocomplain p
        set p [cffi::memory allocate 8]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        cffi::memory get $p void 0
    } -result {Invalid value "void". The specified type is not valid for the type declaration context.} -returnCodes error

    # Error in middle value should not change array
    foreach type [list {*}$numericTypes struct.::StructValue] {
        set arrtype "$type\[3\]"
        set val $testValues($type)
        if {$type in $numericTypes} {
            set anotherval 0
        } else {
            set anotherval {2 3}
        }
        test memory-set-$type-bug128-0 "set $type bad value in array" -setup {
            unset -nocomplain p
            set p [cffi::memory new $arrtype [list $val $val $val]]
        } -cleanup {
            if {[info exists p]} {cffi::memory free $p}
        } -body {
            list [cffi::memory get $p $arrtype] \
                [catch {cffi::memory set $p $arrtype [list $anotherval $badValues($type) $val]} errorMsg] \
                [regexp {expected.*but got|Invalid value|missing.*key} $errorMsg] \
                [cffi::memory get $p $arrtype]
        } -result [list [list $val $val $val] 1 1 [list $val $val $val]]
    }
    test memory-set-struct-bug128-1 "set $type bad value in struct" -setup {
        unset -nocomplain p
        set p [cffi::memory new struct.::StructValue {c 0 i 1}]
    } -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        list [cffi::memory get $p struct.::StructValue] \
            [catch {cffi::memory set $p struct.::StructValue {c 99 i x}} errorMsg] \
            [regexp {expected.*but got|Invalid value|missing.*key} $errorMsg] \
            [cffi::memory get $p struct.::StructValue]
    } -result [list [list c 0 i 1] 1 1 [list c 0 i 1]]

    ###################################################

    #
    # memory new
    testnumargs memory-new "cffi::memory new" "TYPE INITIALIZER" "?TAG?"

    foreach {type val} [array get testValues] {
        if {$type ni {string unistring winstring binary}} {
            test memory-new-$type-0 "new $type" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type $val]
                list [cffi::memory get $p $type] [cffi::pointer isvalid $p] [cffi::pointer tag $p]
            } -result [list $val 1 {}]
            test memory-new-$type-1 "new $type with tag" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type $val TAG]
                list [cffi::memory get $p $type] [cffi::pointer isvalid $p] [cffi::pointer tag $p]
            } -result [list $val 1 [namespace current]::TAG]
            test memory-new-$type-2 "new $type with qualified tag" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type $val ::ns::TAG]
                list [cffi::memory get $p $type] [cffi::pointer isvalid $p] [cffi::pointer tag $p]
            } -result [list $val 1 ::ns::TAG]
            test memory-new-$type-alias-0 "new $type aliased" -setup {
                cffi::alias clear
                cffi::alias define ALIAS $type
            } -cleanup {
                cffi::alias clear
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new ALIAS $val]
                list [cffi::memory get $p $type] [cffi::pointer isvalid $p] [cffi::pointer tag $p]
            } -result [list $val 1 {}]
        }
        if {$type in $numericTypes} {
            test memory-new-$type-array-0 "new $type array" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type\[2\] [list 1 $val]]
                cffi::memory get $p $type\[2\]
            } -result [list [expr {$type in $realTypes ? 1.0 : 1}] $val]
            test memory-new-$type-array-1 "new $type array fill extra elements with zeroes" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type\[4\] [list 1 $val]]
                cffi::memory get $p $type\[4\]
            } -result [expr {$type in $realTypes? [list 1.0 $val 0.0 0.0] : [list 1 $val 0 0]}]
        } elseif {$type eq "uuid"} {
            test memory-new-$type-array-0 "new $type array" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type\[2\] [list 5d549ebb-f6e9-4995-af96-095f54fbf1dc $val]]
                cffi::memory get $p $type\[2\]
            } -result [list 5d549ebb-f6e9-4995-af96-095f54fbf1dc $val]
            test memory-new-$type-array-1 "new $type array fill extra elements with zeroes" -cleanup {
                if {[info exists p]} {cffi::memory free $p}
            } -body {
                unset -nocomplain p
                set p [cffi::memory new $type\[2\] [list $val]]
                cffi::memory get $p $type\[2\]
            } -result [list $val 00000000-0000-0000-0000-000000000000]
            
        }
        if {[info exists badValues($type)]} {
            test memory-new-$type-badvalue-0 "new $type bad value" -body {
                cffi::memory new $type $badValues($type)
            } -result {expected.*but got|Invalid value|missing.*key} -returnCodes error -match regexp
        }
    }
    test memory-new-varsize-0 "new varsize" -setup {
        cffi::Struct create S {n int a uchar[n]}
    } -cleanup {
        cffi::memory free $p
        S destroy
    } -body {
        set p [cffi::memory new struct.S {n 2 a {1 2}} S]
        S fromnative $p
    } -result {n 2 a {1 2}}

    test memory-new-varsize-1 "new varsize = 0" -setup {
        cffi::Struct create S {n int a uchar[n]}
    } -cleanup {
        cffi::memory free $p
        S destroy
    } -body {
        set p [cffi::memory new struct.S {n 0 a {}} S]
        S fromnative $p
    } -result {n 0 a {}}

    test memory-get-winchars-multisz-0 "Get a multisz list" -setup {
        set p [cffi::memory new {bytes[100]} "A\x00 \x00B\x00\x00\x00C\x00\x00\x00D\x00E\x00\x00\x00\x00\x00"]
    } -cleanup {
        cffi::memory free $p
    } -constraints win -body {
        cffi::memory get $p {winchars[100] multisz}
    } -result [list {A B} C DE]

    test memory-get-winchars-multisz-1 "Store a multisz list" -cleanup {
        cffi::memory free $p
    } -constraints win -body {
        set p [cffi::memory new {winchars[10] multisz} {{A B} C DE}]
        cffi::memory get $p {winchars[10] multisz}
    } -result [list {A B} C DE]

    test memory-get-winchars-multisz-2 "Store a multisz list - insufficient space" \
        -constraints win \
        -body {
        set p [cffi::memory new {winchars[9] multisz} {{A B} C DE}]
        } -result {Invalid value "{A B} C DE". String length is greater than specified maximum buffer size.} -returnCodes error

    set type struct.::StructValue
    set val $testValues($type)
    test memory-new-$type-array-0 "new $type array" -cleanup {
        if {[info exists p]} {cffi::memory free $p}
    } -body {
        unset -nocomplain p
        set p [cffi::memory new $type\[2\] [list {} $val]]
        cffi::memory get $p $type\[2\]
    } -result [list {c 0 i 0} $val]

    set matrix {string unistring binary}
    if {[onwindows]} {
        lappend matrix winstring
    }

    foreach type $matrix {
        test memory-new-$type-0 "new $type" -body {
            cffi::memory new $type $testValues($type)
        } -result "Invalid value*" -returnCodes error -match glob
    }

    test memory-new-badtype-0 "new bad type" -body {
        cffi::memory new badtype 0
    } -result {Invalid value "badtype". Invalid base type.} -returnCodes error

    test memory-new-badtype-1 "new bad type - void" -body {
        cffi::memory new void 0
    } -result {Invalid value "void". The specified type is not valid for the type declaration context.} -returnCodes error

}

::tcltest::cleanupTests
namespace delete cffi::test
