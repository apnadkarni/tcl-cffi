# (c) 2021 Ashok P. Nadkarni
# See LICENSE for license terms.

namespace eval $NS {
    # Leading space intentional to match main content below to not confuse ruff
    variable _ruff_preamble "        This is the reference for commands in the `$::NS` namespace."
    append _ruff_preamble " See the \[Start page\]($::NS.html) for an introductory usage guide."
    append _ruff_preamble { See [Concepts][::Concepts] for a mapping of C types and program elements to the script level.}
    append _ruff_preamble {

        The package is loaded in standard fashion with `package require`:

        ````
        package require cffi
        ````
    }

    proc call {fnptr args} {
        # Invokes a C function through a function pointer.
        #  fnptr - A pointer value tagged with a [prototype][::Concepts::Prototypes and function pointers]
        #  args - additional arguments to pass to the C function
        #
        # The passed pointer $fnptr tag must corresponding to a function
        # prototype defined through the [prototype function] or
        # [prototype stdcall] commands.
        #
        # Returns the value returned by the invoked C function.
    }
}

namespace eval ${NS}::help {
    proc function {FUNCNAME} {
        # Returns a string describing the syntax for a CFFI wrapped function
        #   FUNCNAME - name of a wrapped function
    }

    proc functions {{FUNCPATTERN *}} {
        # Returns a list of CFFI-wrapped functions matching the pattern `FUNCPATTERN`
        #   FUNCPATTERN - glob pattern to match
        #
        # Note that like Tcl's `info commands` the pattern is interpreted relative
        # to the current namespace. So for example, to obtain the list of
        # commands within a namespace, the namespace must also be included
        # in the pattern. For example,
        #
        # ````
        # cffi::help functions ::libzip::*
        # ````
    }

    namespace export *
    namespace ensemble create
}
