namespace eval Cookbook {
    variable _ruff_preamble {

        While using CFFI to wrap a few ad-hoc functions is fairly straightforward,
        wrapping a large API into a complete package can be more involved as
        decisions how C types are translated to script level annotations. This
        page provides some step-by-step guidance.

        The description below uses the following terms:

        `LIB` - Wrapper object for the shared library
        `INTEGER` - any CFFI [integer types][::Concepts::Integer types]
        `REAL` - any CFFI [floating point type][::Concepts::Floating point types]
        `STRING` - the `string` and `unistring` types, the former with an optional
        encoding attribute.
        `STRUCT` - a [::cffi::Struct] name

        ## Defining a function

        A function definition consists of three components.

        ```` diagram ditaa
        +------------------+ +-----------+ +--------------+
        |Calling convention+ +Return type+ +Parameter list|
        +------------------+ +-----------+ +--------------+
        ````

        Sections below detail definition of each.

        ### Calling convention

        Check the header file or documentation of the function for the expected
        calling convention. Generally, this is only an issue if the application
        supports the 32-bit Windows platform. Note the function calling
        convention may be defined through a macro such as `WINAPI` etc. Most
        Windows OS API's are defined using the stdcall convention. The default C
        language calling convention is either unspecified or `_cdecl` in C
        header files. Most third party API's are defined using this convention.
        CFFI does not support any calling convention other than these two.

        ``` diagram
           +-       -+
        LIB| function|
           | stdcall |
           +-       -+
        ```

        * Define using `stdcall` if the function is defined on 32-bit Windows
        using `__stdcall` or its equivalent. Note on other platforms, including
        64-bit Windows, this is treated as equivalent to `function`

        * Define using `function` otherwise after ensuring it does not use
        some other esoteric platform-specific convention (rare).

        ### Return type declaration

        The annotations applicable for function returns depend on the
        function return type.

        TBD - summary table mapping C -> CFFI

        #### Void returns

        ``` diagram
        void
        ```

        The `void` return type does not permit any annotations.

        **Examples**

        C

        ```
        void tzset(void)
        ```

        CFFI

        ```
        LIBC function tzset void {}
        ```

        #### Integer returns

        ``` diagram
                   +-         +-      -+ -+ +-           +-                 -+ -+
        schar      | {enum E} | bitmask|  | | zero       | lasterror         |  |
        uchar      +-         +-      -+ -+ | nonzero    | winerror          |  |
        short                               | positive   | errno             |  |
        ushort                              | nonnegative| {onerror HANDLER} |  |
        int                                 +-           +-                 -+ -+
        uint
        long
        ulong
        longlong
        ulonglong
        ```

        * If the returned values are constrained to a set and a symbolic
        representation is preferred, optionally add the `enum` attribute with
        the enumeration defined as a literal or separately through the
        [::cffi::enum] command.

        * If a symbolic representation is preferred as above and the value is
        actually a bit mask, optionally add the `bitmask` attribute to have
        the value returned as a list of symbols from the enumeration.

        * If return values may indicate error conditions, add an error checking
        annotation like `zero`, `nonzero` etc.

        * If a error checking annotation is added and additional detail
        is available from the system, add `lasterror`, `winerror` or `errno`
        as appropriate. If error information is available through some other
        API, add the `onerror` handler. This may also be used to filter errors
        or convert error conditions to success.


        **Examples**

        C

        ```
        int open(const char *pathname, int flags);
        ```

        CFFI

        ```
XXX        LIBC open

        ```


        #### Floating point returns

        ``` diagram
        float
        double
        ```

        Floating point types `float` and `double` do not permit any annotations
        on return type declarations.

        **Examples**

        C

        ```
        double sin(double x);
        ```

        CFFI

        ```
        LIBM function sin double {x double}
        ```


        #### Pointer returns

        Pointer return values may be dealt with at the script level either as
        raw pointers or as implicitly dereferenced values.

        * Declare the function as returning a raw pointer if the returned
        pointers point to resources that have to be freeing at a later point.
        If typed as implicitly dereferenced values, the raw pointer will
        not be available for freeing.

        * Declare the function as returning an implicitly dereferenced value
        if the returned pointers point to some internal or static storage that
        does not need to be freed. An example is the `strerror` C runtime library
        function. Note that implicitly dereferenced types are a convenience;
        they may be typed as raw pointers instead while the reverse will likely
        produce memory leaks.

        The type declarations for raw and implicitly dereferenced pointers are
        separately described below.

        ##### Raw pointers

        ``` diagram
                      +-      -+ +-                 -+
        pointer       | counted| | nullok            |
        pointer.TAG   | unsafe | | lasterror         |
        pointer.STRUCT+-      -+ | errno             |
                                 | {onerror HANDLER} |
                                 +-                 -+
        ```


        * The `TAG` and `STRUCT` are optional but recommended wherever possible
        for additional [tag-based][::Concepts::Pointer tags] type checks.

        * `STRUCT` is a tag matching the name of a previous struct definition.
        If the C pointer target is a C struct defined with [::cffi::Struct],
        it is recommended, but not mandatory, that the tag used be the name of
        the struct instance command. This makes it convenient to access the referenced
        memory using the struct [methods][::cffi::Struct].

        * By default, pointers returned from functions are marked as
        [safe pointers][::Concepts::Pointer safety]. This is appropriate for
        unique pointers that are returned for allocated resources and are only valid
        until they are deallocated through a corresponding *free* function.
        A variation is when the pointer returned is not unique as is the case
        for reference counted resources. In this case the pointer should be
        annotated as `counted`. For cases where neither of the above apply, for
        example there is no clear transfer of ownership or freeing, or pointers
        are internal to the API, there are two choices. First, it can be defaulted as
        a safe pointer. In this case, since there is no *free* function, the
        [::cffi::pointer dispose] command must be called at the appropriate time
        by the application to unregister the pointer. Alternatively, the
        `unsafe` annotation can be added to the declaration. In this case,
        there is no need to unregister the pointer but it can only be used
        in places (arguments and struct fields) that also have the `unsafe`
        annotation. For more details on pointer management and safety,
        see [Pointer safety][::Concepts::Pointer safety].

        * Irrespective of the pointer safety annotations, NULL pointers returned
        from functions will by default raise a generic *Pointer is NULL* exception.
        As for integer return values, if additional information is available from
        the system or API, the type can be annoted with `lasterror`, `errno`
        or `onerror`. On the other hand, if a NULL pointer is a valid return
        value, the `nullok` annotation will suppress the exception and return
        a NULL pointer at the script level.

        **Examples**

        C

        ```
        void *malloc(size_t sz);
        FILE *fopen(const char *pathname, const char *mode);
        git_tree_entry *git_tree_entry_byname(git_tree *, const char *filename);
        ```

        CFFI

        ```
        LIBC malloc {pointer errno} {sz size_t}
        LIBC fopen {pointer.FILE errno} {pathname string mode string}
        LIBGIT git_tree_entry_byname {pointer.git_tree_entry unsafe} {
            pTree {pointer.git_tree counted}
            filename string
            }
        ```

        The `unsafe` and `counted` annotations on `git_tree_entry_byname` arise
        from the libgit2 API. The returned pointer is internal to libgit2 and
        hence marked as unsafe while `git_tree` structs are reference counted.

        ##### Implicitly dereferenced pointers

        Raw pointers at script level, while as versatile as their C counterparts,
        are not as convenient to use as plain old values. Additional steps are
        needed to access the memory as script level values. Declaring pointer
        return types as implicitly dereferenced obviates the need for this
        additional step. As stated earlier, implicit dereferencing should only
        be done when there is no need for the pointer value itself for freeing
        later.

        For types **other than pointers to character (or unicode) strings**, the
        CFFI declaration has the form

        ``` diagram
                  +-      -+
        TYPE byref| nullok |
                  +-      -+
        ```

        where `TYPE` may be one of the numeric types or a `STRUCT`.
        The `byref` annotation on the return type declaration denotes that
        the function return value is nominally a pointer that references
        the true function result.

        **Examples**

        C

        ```
        struct git_oid *git_tree_oid(git_tree *pTree);
        ```

        CFFI

        ```
        LIBGIT function git_tree_oid {struct.git_oid byref} {pTree pointer.git_tree}
        ```

        A call to the `git_tree_oid` function will then return the `git_oid`
        struct (assumed defined previously with [::cffi::Struct]) in its
        script level dictionary form. The actual C level pointer is not
        accessible but not needed as it is internal to the `git_tree` and
        not to be freed or manipulated.

        As for raw pointers, a null pointer return will raise an exception
        by default. The `nullok` annotation may suppress the exception in the
        case that `TYPE` is a struct with defaults defined for all fields
        (possibly with the `-clear` option). In that the dictionary
        corresponding to a struct value with all fields defaulted is returned.
        For all other types and structs with at least one field without a
        default, an exception is raised irrespective of `nullok`.

        For C pointers typed as `char *` which return pointers to character
        strings, the implicit dereference syntax is

        ``` diagram
              +-      -+
        STRING| nullok |
              +-      -+
        ```

        The `byref` is not present because `string` and `unistring` are
        already implicit pointers,
        (`string byref` would correspond to `char **`, not `char *`).
        An optional `nullok` annotation will cause a NULL pointer return
        to be mapped to the empty string instead of generating an exception.

        Note that if `STRING` is `string`, an encoding identifier may be
        optionally attached, e.g. `string.utf-8`.

        **Examples**

        C

        ```
        const char *strerror(int);
        char *strstr(const char *haystack, const char *needle);
        ```

        CFFI

        ```
        LIBC function strerror string {error_code int}
        LIBC function strstr {string nullok} {haystack string needle string}
        ```

        Note the definition of `strstr` to return an empty string if the
        needle is not found instead of raising an exception.


        #### Struct returns

        ``` diagram
        struct.STRUCT
        ```

        A struct function return type does not permit any annotations.
        `STRUCT` must be a previously defined [::Struct][::Concepts::Structs].
        Returning a struct by value is rarely seen in C API's.


        **Examples**

        C

        ```
        typedef struct {
            int quot;
            int rem;
        } div_t;
        div_t div (int numer, int denom);
        ```

        CFFI

        ```
        Struct create div_t {quot int rem int}
        LIBC function struct.div_t {numer int denom int}
        ```

        ### Parameter declaration

        Parameters to a C function may be used to pass values to the function
        (input parameters), retrieve values from the function (output parameters),
        or (input-output parameters).

        Scalar values and structs that are passed by value are always input
        parameters. Input parameters may also be passed by reference via a pointer,
        generally with a `const` attribute to indicate the function does not
        modify the referenced value.

        Output and input-output parameters are always passed to C function
        as pointers to a location where the value is stored. At the script level
        the argument is the name of the variable where the value is stored and
        not the value itself.

        TBD - summary table mapping C -> CFFI

        #### Integer parameters

        ##### Integer input parameters

        ``` diagram
                  +- -+ +-   -+ +-      -+ +-     -+ +-         -+ +-               -+
        schar     |in | |byref| |{enum E}| |bitmask| |{default N}| |lasterror        |
        uchar     +- -+ +-   -+ +-      -+ +-     -+ +-         -+ |winerror         |
        short                                                      |errno            |
        ushort                                                     |{onerror HANDLER}|
        int                                                        +-               -+
        uint
        long
        ulong
        longlong
        ulonglong
        ```

        * The `in` annotation is optional because it is the default if neither
        `out` nor `inout` annotations are present.

        * The `byref` annotation should be specified iff the value is being
        passed by reference, i.e. the function parameter is a pointer to the
        value (e.g. `int *` at the C level). This is very rare for integer
        values that are input only. In either case, whether the `byref`
        parameter is present or not, the value at script level is still
        specified directly and not through a variable.

        * Add the `enum` annotation to pass
        [enumeration][::Concepts::Enumerations] symbolic values for readability
        purposes. Note integer values will still be accepted.

        * If the parameter holds a bit mask, add the `bitmask` annotation which
        allows the argument to be a list of integers which will be bitwise
        OR-ed to construct the value passed to the function. May be combined
        with `enum` to pass a list of symbols.

        * The `default` annotation may be used to supply a default value to
        be passed if no argument is supplied for the parameter when the function
        is invoked. All succeeding parameter in the parameter list must also
        have default annotations.

        * Error handling annotations like `errno` may be present but are
        ignored. This is to permit the same aliases to be used in both return
        and parameter declarations.


        **Examples**

        C

        ```
        int SetHandleInformation(void * hObject, unsigned long dwMask, unsigned long dwFlags);
        ```

        CFFI

        ```
        cffi::enum define HANDLE_FLAGS {INHERIT 1 PROTECT_FROM_CLOSE 2}
        KERNEL32 stdcall SetHandleInformation {int nonzero lasterror} {
            hObject pointer
            dwMask {ulong {enum HANDLE_FLAGS} bitmask}
            dwFlags {ulong {enum HANDLE_FLAGS} bitmask}
        }
        ```


        ##### Out and in-out integer parameters

        ``` diagram
                        +-   -+ +-      -+ +-     -+ +-          -+ +-               -+
        schar     out   |byref| |{enum E}| |bitmask| |storeonerror| |lasterror        |
        uchar     inout +-   -+ +-      -+ +-     -+ |storealways | |winerror         |
        short     retval                             +-          -+ |errno            |
        ushort                                                      |{onerror HANDLER}|
        int                                                         +-               -+
        uint
        long
        ulong
        longlong
        ulonglong
        ```

        * Output and in-out parameters in C are always passed as pointers
        to the location where output value is to be stored. Thus `out` and
        `inout` always imply `byref` which is redundant and need not be specified.

        * The script level argument corresponding to `out` and `inout` parameters
        are the name of the variable to which the output value is to be assigned.
        For `inout` parameters this must exist at the time of function call and
        hold a valid value for the type.

        * Use the `retval` annotation for output parameters where you want the
        output parameter value from the function to be returned as the
        function result in lieu of the actual function return value.
        See [Output parameters as function result][::Concepts::Output parameters as function result].

        * Add the `enum` annotation if output values are to be mapped to
        symbolic names for readability. Further, if the values returned
        are actually bitmasks, add `bitmask` to have the returned value
        transformed to a list of symbolic names.

        * If the function return value is subject to error checks
        (for example null pointer checks) and fails the checks, output
        values are not stored in variables as they may hold garbage values.
        The `storealways` annotation indicates the output value is
        valid regardless of function failure. The `storeonerror` annotation
        indicates the output value is valid **only** on function failure
        (for example an error code). See
        [Errors and output parameters][::Concepts::Errors and output parameters].

        * Error handling annotations like `errno` may be present but are
        ignored. This is to permit the same aliases to be used in both return
        and parameter declarations.

        **Examples**

        C

        ```
        int GetHandleInformation(void*  hObject, unsigned long *lpdwFlags);
        ```

        CFFI

        ```
        cffi::enum define HANDLE_FLAGS {INHERIT 1 PROTECT_FROM_CLOSE 2}
        KERNEL32 stdcall GetHandleInformation {int nonzero lasterror} {
            hObject pointer
            flags {ulong retval {enum HANDLE_FLAGS} bitmask}
        }
        ```

        # TODO
        double output parameter
        double modf (double x, double* intpart);


        #### Floating point parameters

        ##### Floating point input parameters

        ``` diagram
               +- -+ +-   -+ +-         -+
        float  |in | |byref| |{default N}|
        double +- -+ +-   -+ +-         -+
        ```

        * The `in` annotation is optional because it is the default if neither
        `out` nor `inout` annotations are present.

        * The `byref` annotation should be specified iff the value is being
        passed by reference, i.e. the function parameter is a pointer to the
        value (e.g. `double *` at the C level). This is very rare for integer
        values that are input only. In either case, whether the `byref`
        parameter is present or not, the value at script level is still
        specified directly and not through a variable.

        * The `default` annotation may be used to supply a default value to
        be passed if no argument is supplied for the parameter when the function
        is invoked. All succeeding parameter in the parameter list must also
        have default annotations.

        **Examples**

        C

        ```
        double sin(double x);
        ```

        CFFI

        ```
        LIBM sin double {x double}
        ```

        ##### Out and in-out floating point parameters

        ``` diagram
                       +-   -+ +-          -+
        float    out   |byref| |storeonerror|
        double   inout +-   -+ |storealways |
                 retval        +-          -+
        ```

        * Output and in-out parameters in C are always passed as pointers
        to the location where output value is to be stored. Thus `out` and
        `inout` always imply `byref` which is redundant and need not be specified.

        * The script level argument corresponding to `out` and `inout` parameters
        are the name of the variable to which the output value is to be assigned.
        For `inout` parameters this must exist at the time of function call and
        hold a valid value for the type.

        * Use the `retval` annotation for output parameters where you want the
        output parameter value from the function to be returned as the
        function result in lieu of the actual function return value.
        See [Output parameters as function result][::Concepts::Output parameters as function result].

        * If the function return value is subject to error checks
        (for example null pointer checks) and fails the checks, output
        values are not stored in variables as they may hold garbage values.
        The `storealways` annotation indicates the output value is
        valid regardless of function failure. The `storeonerror` annotation
        indicates the output value is valid **only** on function failure
        (for example an error code). See
        [Errors and output parameters][::Concepts::Errors and output parameters].

        #### Struct parameters

        Struct values are represented as the script level as dictionaries.
        This requires their definition as described in
        [Structs][::Concepts::Structs] and [Defining structs].

        ##### Struct input parameters

        ``` diagram
                      +- -+ +-   -+ +-         -+ +-         -+
        struct.STRUCT |in | |byref| |{default N}| |nullifempty|
                      +- -+ +-   -+ +-         -+ +-         -+
        ```

        * The `in` annotation is optional because it is the default if neither
        `out` nor `inout` annotations are present.

        * The `byref` annotation should be specified iff the value is being
        passed by reference, i.e. the function parameter is a pointer to a
        struct value that is to be passed. Generally, input parameters passed
        by reference will have `const` in the C parameter declaration.
        Irrespective of this annotation, the argument is always a dictionary,
        not a pointer.

        * The `default` annotation may be used to supply a default value to
        be passed if no argument is supplied for the parameter when the function
        is invoked. All succeeding parameter in the parameter list must also
        have default annotations.

        * Some C functions accept a NULL pointer for optional parameters.
        The `nullifempty` annotation identifies such parameters. In this case,
        passing an empty dictionary as the script level argument will result
        in a NULL pointer being passed to the function. This annotation
        only makes sense in the presence of the `byref` annotation.

        **Examples**

        C

        ```
        int git_checkout_head(git_repository *repo, const git_checkout_options *opts);
        ```

        CFFI

        ```
        cffi::Struct create git_checkout_options {...}
        LIBGIT function git_checkout_head {int zero} {
            pRepo pointer.git_repository
            opts  {struct.git_checkout_options byref nullifempty}
        }
        ```

        ##### Out and in-out struct parameters

        ``` diagram
                            +-   -+ +-          -+
        struct.STRUCT out   |byref| |storeonerror|
                      inout +-   -+ |storealways |
                      retval        +-          -+
        ```

        * Output and in-out parameters in C are always passed as pointers
        to the location where output value is to be stored. Thus `out` and
        `inout` always imply `byref` which is redundant and need not be specified.

        * The script level argument corresponding to `out` and `inout` parameters
        are the name of the variable to which the output value is to be assigned.
        For `inout` parameters this must exist at the time of function call and
        hold a valid value for the type.

        * Use the `retval` annotation for output parameters where you want the
        output parameter value from the function to be returned as the
        function result in lieu of the actual function return value.
        See [Output parameters as function result][::Concepts::Output parameters as function result].

        * If the function return value is subject to error checks
        (for example null pointer checks) and fails the checks, output
        values are not stored in variables as they may hold garbage values.
        The `storealways` annotation indicates the output value is
        valid regardless of function failure. The `storeonerror` annotation
        indicates the output value is valid **only** on function failure
        (for example an error code). See
        [Errors and output parameters][::Concepts::Errors and output parameters].
        These annotations are rarely applicable to struct output parameters.

        **Examples**

        C

        ```
        int GetWindowRect(void *hWnd, RECT *lpRect);
        ```

        CFFI

        ```
        cffi::Struct create RECT {left int top int right int bottom int}
        LIBUSER32 stdcall GetWindowRect int {hwnd pointer rect {struct.RECT out}}
        ```

        #### String parameters

        ##### Input string parameters

        C does not have a string type and the `string` and `unistring`
        CFFI types map to pointers to nul terminated character strings:
        `char*` in the case of `string` and `Tcl_UniChar *` in the case
        of `unistring`.

        ``` diagram
                        +- -+ +-         -+ +-   -+
        string          |in | |nullifempty| |byref|
        string.ENCODING +- -+ +-         -+ +-   -+
        unistring
        ```

        * The `in` annotation is optional because it is the default if neither
        `out` nor `inout` annotations are present.

        * For the `string` type an optional encoding may be specified and
        defaults to the system encoding. If a library API uses a specific
        encoding (commonly UTF-8), it may be convenient to define a type
        alias.

        * The `byref` annotation should be specified iff the value is being
        passed by reference, i.e. the function parameter is a pointer to the
        pointer to the character string (double indirection)
        This is rare for passing character string values
        that are input only. In either case, whether the `byref`
        parameter is present or not, the value at script level is still
        specified directly and not through a variable.

        * Some C functions accept a NULL pointer for optional parameters.
        The `nullifempty` annotation identifies such parameters. In this case,
        passing an empty string as the script level argument will result
        in a NULL pointer being passed to the function.

        ##### Input and output string parameters

        Character strings are returned from C functions in one of two ways:

        * The C function expects the caller to supply a pointer to an array of
        characters. The size of this array may be a compile time constant or
        passed through another parameter to the function. The function then
        stores the string in this buffer. The C parameter declaration is
        of the form `char *buf` or `char buf[]`.

        * The C function expects the caller to pass a pointer to a memory
        location where it will store the pointer to a string that is either
        dynamically allocated or an internal static string. The C declaration
        is of the form `char **ptr_to_buf` reflecting the double indirection.

        The two are handled differently in CFFI as described below.

        **Output character arrays**

        ``` diagram
                         +-    -+ +-          -+
        chars[N]         |out   | |storealways |
        chars.ENCODING[N]|inout | |storeonerror|
        unichars[N]      |retval| +-          -+
                         +-    -+
        ```

        This is the first case described above where the C function expects
        a pointer to a character (or `Tcl_UniChar` in the case of `unichars`)
        array.

        * The script level argument corresponding to `out` and `inout` parameters
        are the name of the variable to which the output value is to be assigned.
        For `inout` parameters this must exist at the time of function call and
        hold a valid value for the type.

        * Use the `retval` annotation for output parameters where you want the
        output parameter value from the function to be returned as the
        function result in lieu of the actual function return value.
        See [Output parameters as function result][::Concepts::Output parameters as function result].

        * The array size `N` in the declaration may either be an integer constant
        or the name of a integer type parameter in the same function declaration.
        See [Dynamically sized arrays][::Concepts::Dynamically sized arrays].

        * If `ENCODING` is not specified, it defaults to the system encoding.

        * If the function return value is subject to error checks
        (for example null pointer checks) and fails the checks, output
        values are not stored in variables as they may hold garbage values.
        The `storealways` annotation indicates the output value is
        valid regardless of function failure. The `storeonerror` annotation
        indicates the output value is valid **only** on function failure
        (for example an error code). See
        [Errors and output parameters][::Concepts::Errors and output parameters].


        **Examples**

        C

        ```
        char *getcwd(char *buf, size_t size);
        ```

        CFFI

        ```
        LIBC function getcwd {string errno} {buf {chars[size] out} size size_t}
        ```

        **Output pointers to strings

        The second case is when the C function parameter is a pointer to
        pointer to a character string (`char **`).

        How this is best handled depends on whether the returned pointer needs
        to be available at the script level as a raw pointer, possibly for later
        freeing. See [Pointer returns] for a more detailed discussion about
        raw pointers versus implicit dereferencing.
        If this is the case, see [Pointer out and in-out parameters] for
        appropriate declarations.

        If retention of the raw pointer is not required
        (for example, pointer to static storage), then its most convenient to
        implicitly declare it as an output parameter of

        ``` diagram
                        +-    -+ +-    -+ +-          -+
        string          |out   | |nullok| |storealways |
        string.ENCODING |retval| +-    -+ |storeonerror|
        unistring       +-    -+          +-          -+
        ```
        * Output parameters in C are always passed as pointers
        to the location where output value is to be stored. Thus `out`
        always implies `byref` which is redundant and need not be specified.

        * The script level argument corresponding to an `out` parameter
        is the name of the variable to which the output value is to be assigned.

        * Use the `retval` annotation for output parameters where you want the
        output parameter value from the function to be returned as the
        function result in lieu of the actual function return value.
        See [Output parameters as function result][::Concepts::Output parameters as function result].

        * If the function return value is subject to error checks
        (for example null pointer checks) and fails the checks, output
        values are not stored in variables as they may hold garbage values.
        The `storealways` annotation indicates the output value is
        valid regardless of function failure. The `storeonerror` annotation
        indicates the output value is valid **only** on function failure
        (for example an error code). See
        [Errors and output parameters][::Concepts::Errors and output parameters].
        These annotations are rarely applicable to struct output parameters.

        #### Pointers



        **Examples**

        C

        ```
        int ConvertSidToStringSidA(SID *pSid, char **strSid);
        ```

        CFFI

        ```
        ADVAPI32 stdcall ConvertSidToStringSidA {int nonzero lasterror} {
            pSid   pointer.SID
            strSid pointer
        }
        KERNEL32 stdcall LocalFree {pointer nullok} {p {pointer dispose}}
        ```

        In this Win32 example, the returned pointer from `ConvertSidToStringSidW`
        needs to be freed with `LocalFree` and hence needs to be declared
        as a raw pointer. The string can be retrieved from the returned
        pointer with [::cffi::memory tostring] before freeing it.

        #### Binary arrays

        #### Arrays


        ## Defining callbacks

        *This section to be written**

        ## Defining structs

        *This section to be written**

        ## Tips and tricks

        *This section to be written**

        - understand the memory ownership conventions
        - duplicating structure or function definition

    }

}
